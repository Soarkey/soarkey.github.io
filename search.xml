<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SiamAttn</title>
      <link href="/2020/06/08/siamattn/"/>
      <url>/2020/06/08/siamattn/</url>
      
        <content type="html"><![CDATA[<h1 id="deformable-siamese-attention-networks-for-visual-object-trackingsiamattn"><a class="markdownIt-Anchor" href="#deformable-siamese-attention-networks-for-visual-object-trackingsiamattn"></a> Deformable Siamese Attention Networks for Visual Object Tracking【SiamAttn】</h1><blockquote><p><img src="/2020/06/08/siamattn/image-20200606150148134.png" alt="image-20200606150148134"></p><p>📄 paper: <a href="https://arxiv.org/pdf/2004.06711v1.pdf">https://arxiv.org/pdf/2004.06711v1.pdf</a></p><p>🏙码隆科技: <a href="https://www.malong.com/cn/research.html">https://www.malong.com/cn/research.html</a></p><p>CVPR 2020</p></blockquote><a id="more"></a><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p><strong>Siamese系列问题：</strong></p><ul><li><p>没有在线更新；</p></li><li><p>模板分支和搜索分支完全独立，一些<strong>背景信息</strong>无法得到有效利用。</p></li></ul><p><strong>注意力机制的应用：</strong></p><ol><li><p><strong>RASNet：</strong></p><p><img src="/2020/06/08/siamattn/image-20200608093015025.png" alt="image-20200608093015025"></p><p>三种注意力：</p><ul><li>残差注意力块、通道注意力块和通用注意力块</li></ul><p><img src="/2020/06/08/siamattn/image-20200608091816705.png" alt="image-20200608091816705"></p><p>创新：</p><ul><li>多个注意力机制使得网络不需要进行在线更新操作，其实是将更新操作换做注意力机制来做；</li><li>通过残差注意力机制和通道注意力机制在缓解网络过拟合的同时提升网络的判别能力；</li><li>考虑到视频中的时空信息，并通道注意力机制来获得</li></ul></li><li><p><strong>FlowTrack</strong></p><p><a href="https://blog.csdn.net/qinhuai1994/article/details/80461271">https://blog.csdn.net/qinhuai1994/article/details/80461271</a></p><p><img src="/2020/06/08/siamattn/image-20200608095719104.png" alt="image-20200608095719104"></p><p>网络架构：</p><p><img src="/2020/06/08/siamattn/image-20200608093821599.png" alt="image-20200608093821599"></p><p>创新：</p><ul><li><p>历史帧：光流+CNN特征，用来补全当前帧的特征，增强鲁棒性；</p></li><li><p>空间注意力 Spatial attention</p><p><img src="/2020/06/08/siamattn/image-20200608095046008.png" alt="image-20200608095046008"></p></li><li><p>时序注意力 Temporal attention (channel attention)</p><p><img src="/2020/06/08/siamattn/image-20200608094712370.png" alt="image-20200608094712370"></p></li></ul></li></ol><p>上述两种方法应用注意力机制的缺点：</p><ul><li>模板分支和搜索分支独立计算注意力</li></ul><h1 id="2-细节"><a class="markdownIt-Anchor" href="#2-细节"></a> 2. 细节</h1><p>从Dual attention network for scene segmentation受启发：</p><p><img src="/2020/06/08/siamattn/image-20200608124833163.png" alt="image-20200608124833163"></p><p>三种Attention机制：</p><ul><li>Self-Attention</li><li>Cross-Attention</li><li>Deformable Attention</li></ul><p>网络架构：</p><p><img src="/2020/06/08/siamattn/image-20200608104249744.png" alt="image-20200608104249744"></p><p><img src="/2020/06/08/siamattn/image-20200608104315288.png" alt="image-20200608104315288"></p>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
          <category> Attention </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> Attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SiamBAN</title>
      <link href="/2020/06/03/siamban/"/>
      <url>/2020/06/03/siamban/</url>
      
        <content type="html"><![CDATA[<h1 id="siamese-box-adaptive-network-for-visual-trackingsiamban"><a class="markdownIt-Anchor" href="#siamese-box-adaptive-network-for-visual-trackingsiamban"></a> Siamese Box Adaptive Network for Visual Tracking【SiamBAN】</h1><blockquote><p><img src="/2020/06/03/siamban/image-20200525183543042.png" alt="image-20200525183543042"></p><p>📄 paper: <a href="https://arxiv.org/pdf/2003.06761.pdf">https://arxiv.org/pdf/2003.06761.pdf</a></p><p>💻code: <a href="https://github.com/hqucv/siamban">https://github.com/hqucv/siamban</a></p><p>CVPR 2020</p></blockquote><a id="more"></a><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p>缺陷：</p><ul><li>CF类ECO/UPDT：依赖于分类分支，只靠多尺度搜索来估算目标的尺度。</li><li>Siamese系列SiamRPN/DaSiamRPN/SiamRPN++：需要设计anchor box超参数，计算复杂。</li></ul><p>动机：</p><p>​来自神经科学的研究，生物的视觉不需要依靠候选框，主视觉皮层就能快速有效地提取目标的轮廓和边界。所以我们是否可以设计一种不依赖候选框的鲁棒的视觉追踪框架？受到目标检测中Anchor-free检测器的启发。</p><h1 id="2-细节"><a class="markdownIt-Anchor" href="#2-细节"></a> 2. 细节</h1><p><img src="/2020/06/03/siamban/image-20200601143104215.png" alt="image-20200601143104215"></p><p>​采用ResNet-50作为Siamese网络的backbone，box adaptive head包括一个分类模块和一个回归模块。</p><ul><li>为了解决ResNet50降低了特征分辨率的问题，作者移除了最后两个卷积block的下采样操作；</li><li>为了增大感受野（receptive field），采用了空洞卷积（atrous convolution），【文中说在SiamRPN/SiamMask中证明了有效？】；</li><li>采用了不同的膨胀率（atrous rate），在conv4和conv5 block中设置stride都为1，atrous rate中conv4为2，conv5为4。</li><li>Multi-level  Prediction：类似于SiamRPN++，作者对conv3-5的特征图进行depth-wise cross-correlation，后再对三个层做自适应加权融合<br><img src="/2020/06/03/siamban/20200323152713812.png" alt="img" style="zoom:200%;"></li><li></li></ul><blockquote><p>问题：如何避免不同层次的重复检测？</p></blockquote><blockquote><p>从classification/regression map变换回和search patch等大小的方法：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">⌊</mo><mfrac><msub><mi>w</mi><mrow><mi>i</mi><mi>m</mi></mrow></msub><mn>2</mn></mfrac><mo stretchy="false">⌋</mo><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mo stretchy="false">⌊</mo><mfrac><mi>w</mi><mn>2</mn></mfrac><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo><mo>×</mo><mi>s</mi><mo separator="true">,</mo><mo stretchy="false">⌊</mo><mfrac><msub><mi>h</mi><mrow><mi>i</mi><mi>m</mi></mrow></msub><mn>2</mn></mfrac><mo stretchy="false">⌋</mo><mo>+</mo><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mo stretchy="false">⌊</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo><mo>×</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\lfloor \frac{w_{im}}{2} \rfloor + (i-\lfloor \frac{w}{2} \rfloor)\times s, \lfloor \frac{h_{im}}{2} \rfloor + (j-\lfloor \frac{h}{2} \rfloor)\times s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mopen">[</span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span></span></p><p><img src="/2020/06/03/siamban/image-20200602120406328.png" alt="image-20200602120406328"></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># resized = cv2.resize(img, (342, 342))</span></span><br><span class="line"><span class="comment"># cv2.imwrite('resized_img.jpg', resized)</span></span><br><span class="line">img = cv2.imread(<span class="string">'resized_img.jpg'</span>)</span><br><span class="line"><span class="comment"># img.shape (342, 342, 3)</span></span><br><span class="line">x = np.zeros((<span class="number">684</span>, <span class="number">684</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># x.shape (684, 684, 3)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">342</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">342</span>):</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">x[<span class="number">342</span>+(i<span class="number">-171</span>)*<span class="number">2</span>,<span class="number">342</span>+(j<span class="number">-171</span>)*<span class="number">2</span>,k] = img[i,j,k]</span><br><span class="line">cv2.imwrite(<span class="string">'x.jpg'</span>, x)</span><br></pre></td></tr></table></figure><p><img src="/2020/06/03/siamban/image-20200602122959610.png" alt="image-20200602122959610"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
          <category> Attention </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> Attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LTMU笔记</title>
      <link href="/2020/05/26/ltmu-bi-ji/"/>
      <url>/2020/05/26/ltmu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="high-performance-long-term-tracking-with-meta-updaterltmu"><a class="markdownIt-Anchor" href="#high-performance-long-term-tracking-with-meta-updaterltmu"></a> High-Performance Long-Term Tracking with Meta-Updater【LTMU】</h1><blockquote>  <img src="/2020/05/26/ltmu-bi-ji/image-20200516203018522.png"><p>📄 paper: <a href="https://arxiv.org/pdf/2004.00305.pdf">https://arxiv.org/pdf/2004.00305.pdf</a></p><p>💻 code: <a href="https://github.com/Daikenan/LTMU">https://github.com/Daikenan/LTMU</a></p><p>🌟【CVPR2020 Oral】</p></blockquote><a id="more"></a><h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h1><ol><li><p>提出了一种新颖的离线训练元更新器，有效地指导了在线跟踪器的更新。</p></li><li><p>在线本地(局部)跟踪器的基础上，引入了长期跟踪框架。提出的长期跟踪框架在低风险的情况下可受益于在线更新的短期跟踪器的优势。</p><p>Meta-Updater的提出是为了解决一个重要但悬而未决的问题：什么时刻应该更新当前帧？（Is the tracker ready for updating in the current frame?）该元更新器可以按顺序方式有效地整合几何、判别和外观线索，然后使用级联LSTM模块挖掘序列信息。该元更新器学习二进制输出以指导跟踪器的更新，并且可以轻松地嵌入到不同的跟踪器中。</p></li></ol><p>**核心：**长期跟踪+元更新器（Meta-Updater）</p><p>[ ▶ tracking speed  13 FPS]</p><p>Intel-i9 CPU（64G RAM）+NVIDIA GTX2080Ti GPU（11G memory）</p><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><ol><li><p><strong>几何信息（Geometric Cue）</strong>：目标的bounding box信息，就是每帧目标的位置和尺度信息</p></li><li><p><strong>判别信息（Discriminative Cue）</strong>：这里其实就是在线的tracker输出信息（tracker scores， response map），这个信息是非常关键的，很多tracker都是利用这个信息来控制更新的，比如MDNet类，通过看最大的5个分类score的平均值是否大于零来判断是否用这个样本来更新，ATOM通过response map的最大值和形状来判断是否更新。</p></li><li><p><strong>外观信息（Appearance Cue）</strong>：tracker每帧跟踪结果的图片信息和第一帧真值的图片信息。</p></li><li><p><strong>时序信息（Sequential Information）</strong>：对上面信息引入时序，比如几何信息，单独的几何信息信息量很有限，但是引入时序后就可以包含很多信息了，比如轨迹信息，速度信息，加速度信息，尺度变化信息。</p></li></ol><p><img src="/2020/05/26/ltmu-bi-ji/image-20200516214140332-1592291613452.png" alt="image-20200516214140332"></p><h1 id="2-方法"><a class="markdownIt-Anchor" href="#2-方法"></a> 2. 方法</h1><p><img src="/2020/05/26/ltmu-bi-ji/image-20200526110004333.png" alt="image-20200526110004333"></p><p><img src="/2020/05/26/ltmu-bi-ji/image-20200522103348181.png" alt="image-20200522103348181"></p><p><img src="/2020/05/26/ltmu-bi-ji/image-20200523100900734.png" alt="image-20200523100900734"></p><p>local tracker： ATOM+SiamMask</p><p>global tracker： SiamRPN</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li><p>【精】【作者】CVPR2020 Oral， LTMU，给跟踪器学习一个长时更新控制器 <a href="https://zhuanlan.zhihu.com/p/130322874">https://zhuanlan.zhihu.com/p/130322874</a></p></li><li><p>High-Performance Long-Term Tracking with Meta-Updater CVPR2020 论文笔记 <a href="https://blog.csdn.net/CptOctopus/article/details/105345965">https://blog.csdn.net/CptOctopus/article/details/105345965</a></p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
          <category> LSTM </category>
          
          <category> Meta Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> LSTM </tag>
            
            <tag> Meta-Learning </tag>
            
            <tag> Meta-Updater </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAML笔记</title>
      <link href="/2020/05/23/maml-bi-ji/"/>
      <url>/2020/05/23/maml-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="mamltracking-by-instance-detection-a-meta-learning-approach"><a class="markdownIt-Anchor" href="#mamltracking-by-instance-detection-a-meta-learning-approach"></a> 【MAML】Tracking by Instance Detection: A Meta-Learning Approach</h1><blockquote><p><img src="/2020/05/23/maml-bi-ji/image-20200501141721053.png" alt="image-20200501141721053"></p><p>paper: <a href="https://arxiv.org/abs/2004.00830">https://arxiv.org/abs/2004.00830</a></p></blockquote><p>MAML :  model-agnostic meta-learning</p><a id="more"></a><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p>​跟踪可以看成是一个特殊的检测问题，即instance detection。主要的区别在于目标检测可以定位某些预定义类别的对象，并且其输出不会在intra-class实例之间进行区分；但是目标追踪仅查找特定实例，该实例可能属于初始帧中指定的任何已知或未知的对象类别。</p><p>​因为两者的相似性，很多目标检测的技术可以应用在目标追踪上面，例如，Faster R-CNN中的RPN网络应用在SiamRPN追踪器及其变体；multi-aspect-ratio anchors解决了困扰之前追踪器的box estimation问题；IoU-Net也应用于ATOM和DiMP中。</p><p>​<strong>给定合适的初始化，检测器从单帧中快速学习实例信息从而转变成一个跟踪器</strong>。难点就在于如何给这个初始化使得模型在少量样本的情况下就能学到一个新的instance的信息而不会过拟合，这就是一个domain adaptation的问题，而model-agnostic meta-learning (MAML) 无疑是解决这种问题的一个利器。</p><p>​这样，我们就可以将一个检测器通过domain adaptation转变成适合某个特定domain （或者说是instance）的跟踪器，下图形象地展示了这个过程。</p><p><img src="/2020/05/23/maml-bi-ji/image-20200503174910896.png" alt="image-20200503174910896"></p><p>具体应用MAML的将detector转变为tracker的流程如下：</p><ol><li><p>使用gradient descent训练一般的检测器；</p></li><li><p>使用MAML在大量跟踪序列上离线训练；</p></li><li><p>给定测试序列第一帧信息后，通过几步gradient descent 来 fine-tune模型参数做domain adaptation从而得到一个跟踪器。跟踪过程中，当目标外观发生变化时，可以用更多样本进行fine-tune得到更好的适应能力。</p></li></ol><p>​作者设计了两个instance detector分别为Retina-MAML和 FCOS-MAML代表着anchor-base和anchor-free，分别来源于RetinaNet和FCOS，均取得了不错的结果，并且速度达到实时的40FPS。</p><blockquote><p><strong>RetinaNet(2018):</strong></p><p>paper: <a href="https://arxiv.org/pdf/1708.02002.pdf">https://arxiv.org/pdf/1708.02002.pdf</a></p><p>blog:</p><ul><li><p>目标检测算法 - RetinaNet <a href="https://zhuanlan.zhihu.com/p/67768433">https://zhuanlan.zhihu.com/p/67768433</a></p></li><li><p>RetinaNet: Focal loss在目标检测网络中的应用 <a href="https://www.jianshu.com/p/8e501a159b28">https://www.jianshu.com/p/8e501a159b28</a></p></li><li><p>Review: RetinaNet — Focal Loss (Object Detection) <a href="https://towardsdatascience.com/review-retinanet-focal-loss-object-detection-38fba6afabe4">https://towardsdatascience.com/review-retinanet-focal-loss-object-detection-38fba6afabe4</a></p></li></ul><p><img src="/2020/05/23/maml-bi-ji/5971313-152cb2d4c07fce20.JPG" alt="img"></p><p><strong>FCOS:</strong></p><p>paper: <a href="https://arxiv.org/pdf/1904.01355.pdf">https://arxiv.org/pdf/1904.01355.pdf</a></p><p>blog:</p><ul><li>FCOS:一阶全卷积目标检测 <a href="https://zhuanlan.zhihu.com/p/63868458">https://zhuanlan.zhihu.com/p/63868458</a></li><li>FCOS: 最新的one-stage逐像素目标检测算法 <a href="https://blog.csdn.net/qiu931110/article/details/89073244">https://blog.csdn.net/qiu931110/article/details/89073244</a></li></ul><p><img src="/2020/05/23/maml-bi-ji/image-20200508095947264.png" alt="image-20200508095947264"></p></blockquote><h1 id="2-related-work"><a class="markdownIt-Anchor" href="#2-related-work"></a> 2. Related Work</h1><h2 id="21-cnn-based-visual-object-tracking"><a class="markdownIt-Anchor" href="#21-cnn-based-visual-object-tracking"></a> 2.1 CNN-based visual object tracking</h2><p>​首先介绍CNN-based trackers的一些工作，这里作者按照是否显式的使用模板将其分成了两类。</p><p>​template-based的方法通常有一个模板分支，将目标外观信息存储在显式模板中，如常见的siamese系列的跟踪器。这种方法优点是快，不需要在线更新。难点也是难以找到一个合适的在线更新方法来更新模板，从而无法适应一些目标的变化。(SiamFC, SiamRPN, SPM-Tracker, ATOM/DiMP)</p><p>​另一方面template-free的方法就是将目标外观信息以微调参数的形式存储在网络中，比如MDNet。但这类算法的难点一个是慢，一个是容易过拟合，无法很好将instance信息融合进网络。</p><p>​本文设计了一个template-free trackers，作者认为这类方法的整体架构可以很好的匹配一个检测框架，不需要额外添加其他分支改变结构。</p><h2 id="22-meta-learning-and-its-application-to-tracking"><a class="markdownIt-Anchor" href="#22-meta-learning-and-its-application-to-tracking"></a> 2.2 Meta learning and its application to tracking</h2><p>​介绍一些meta-learning的相关工作以及在跟踪中的应用，不过目前这种方法在跟踪中的应用还不够成熟，有些精度不够高，有些速度太慢了。</p><p>​Model-agnostic meta-learning (MAML) [10] is an im-<br>portant algorithm for meta learning.  The most striking merit of MAML is that it is compatible with any model trained with gradient descent and applicable to a variety of different learning problems.<br>Because of this, MAML is a perfect candidate to realize our idea, which is to convert any advanced object detectors (trained with gradient descent) into a tracker.</p><p>MAML++</p><p>MetaSGD</p><p>​Meta-Tracker第一次使用MAML作为MDNet的domain adaptation step；MetaRTT进一步应用MAML作为在线更新步骤，以此加速现有tracker的在线训练速度。</p><p>​We argue that, since meta learning provides a mechanism to quickly adapt a deep network to model a particular object and avoid overfitting, why not directly convert a modern object detector into a tracker, instead of making a slow tracker faster?</p><blockquote><p>ICCV 2019 Lianghua Huang, Xin Zhao, and Kaiqi Huang. <strong>Bridging the gap between detection and tracking: A unified approach</strong></p><p>paper: <a href="http://openaccess.thecvf.com/content_ICCV_2019/papers/Huang_Bridging_the_Gap_Between_Detection_and_Tracking_A_Unified_Approach_ICCV_2019_paper.pdf">http://openaccess.thecvf.com/content_ICCV_2019/papers/Huang_Bridging_the_Gap_Between_Detection_and_Tracking_A_Unified_Approach_ICCV_2019_paper.pdf</a></p><p>blog:</p><ul><li>[Note2] 目标检测框架在目标跟踪中的应用 <a href="https://www.bilibili.com/read/cv4707398">https://www.bilibili.com/read/cv4707398</a></li></ul><p><img src="/2020/05/23/maml-bi-ji/image-20200508101652361.png" alt="image-20200508101652361"></p><p><img src="/2020/05/23/maml-bi-ji/image-20200508101910940.png" alt="image-20200508101910940"></p></blockquote><h1 id="3-learning-an-instance-detector-with-maml"><a class="markdownIt-Anchor" href="#3-learning-an-instance-detector-with-maml"></a> 3. Learning an Instance Detector with MAML</h1><p>要解决的问题：如何通过MAML来学习一个instance detector？</p><p>​将一个detector转化为instance detector的关键在于提供一个好的初始化。</p><p><mark>[➡pdf]</mark></p><p><img src="/2020/05/23/maml-bi-ji/image-20200508173805473.png" alt="image-20200508173805473"></p><p><img src="/2020/05/23/maml-bi-ji/image-20200508205138579.png" alt="image-20200508205138579"></p><p><img src="/2020/05/23/maml-bi-ji/image-20200508173826254.png" alt="image-20200508173826254"></p><p>​整体的流程如下图所示，这里训练的时候简化了，仅选择一对图片来构建一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，第一张图通过缩放得到3张图作为support set，第二张图就直接作为target set。</p><p><img src="/2020/05/23/maml-bi-ji/image-20200502092252377.png" alt="image-20200502092252377"></p><p>​为了稳定训练，作者添加了一些meta-learning中用到的操作。</p><p><mark><strong>Multi-step loss optimization</strong></mark></p><p>​参照MAML++，将inner-level optimization中GD的每一个step的参数都用来优化target set中的loss，而不是只用最后一步得到的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">θ_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。则公式2可以改写为：</p><p><img src="/2020/05/23/maml-bi-ji/image-20200508173437682.png" alt="image-20200508173437682"></p><p>​值得注意的是初始参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">θ_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>同样被用于计算outer-level loss。</p><p><mark><strong>Kernel-wise learnable learning rate</strong></mark></p><p>​参照MetaSGD，将公式1中inner-level optimization的学习率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>变为可学习的：</p><p><img src="/2020/05/23/maml-bi-ji/image-20200508174139349.png" alt="image-20200508174139349"></p><p>​<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\theta_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>有相同的size，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊙</mo></mrow><annotation encoding="application/x-tex">\odot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊙</span></span></span></span>表示element-wise product，若为每个参数设置学习率会使模型大小增加一倍，所以作者这里使用了kernel-wise的方法，给每个卷积核定义了学习率。（大概）</p><h1 id="4-retina-maml-and-fcos-maml"><a class="markdownIt-Anchor" href="#4-retina-maml-and-fcos-maml"></a> 4. Retina-MAML and FCOS-MAML</h1><p>​这一节就是具体将如何通过开始提到的3个步骤来构建跟踪器。包括detector choices, offline training details 和 online tracking process。</p><h2 id="41-detectors"><a class="markdownIt-Anchor" href="#41-detectors"></a> 4.1 Detectors</h2><p>Anchor-based vs Anchor-free</p><p><img src="/2020/05/23/maml-bi-ji/image-20200502092323876.png" alt="image-20200502092323876"></p><p>​作者分别选取了anchor-base的RetinaNet和anchor-free的FCOS来作为检测器。由于跟踪通常会根据目标大小选择一个搜索区域然后将其resize到固定大小输入到网络中，<mark>所以目标尺度在跟踪任务中通常分布比较集中，不需要FPN这样的结构</mark>。另外对于FCOS只保留了centerness 来预测分类得分（FCOS用了三个network head：一个common regression head和两个centerness/classification heads）；Retinanet只设计了一个64×64大小的anchor。</p><p>​整体网络结构如下图4，Resnet18作为backbone，前3个block在ImageNet预训练后在离线训练时冻结，block5被丢弃，block4（黄色部分）复制一份分别独立作用在分类和回归上。</p><p><img src="/2020/05/23/maml-bi-ji/image-20200502092349927.png" alt="image-20200502092349927"></p><h2 id="42-offline-maml-training"><a class="markdownIt-Anchor" href="#42-offline-maml-training"></a> 4.2 Offline MAML training</h2><p><strong>Loss definition:</strong></p><ul><li><p>Retina-MAML</p><p>Focal loss (classification) + smooth L1 loss (regression)</p></li><li><p>FCOS-MAML</p><p>L2 loss (centerness scores) + L1 loss (regression)</p></li></ul><p><strong>Training data:</strong></p><p>​MS-COCO, GOT10k,  TrackingNet, LaSOT-train</p><ul><li><p>cropped and resized into <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>263</mn><mo>×</mo><mn>263</mn></mrow><annotation encoding="application/x-tex">263\times263</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">3</span></span></span></span></p></li><li><p>data augmentation: random scaling, shifting</p></li></ul><p><strong>Optimization:</strong></p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>What is Model-Agnostic Meta-learning (MAML) ?  <a href="https://towardsdatascience.com/model-agnostic-meta-learning-maml-8a245d9bc4ac">https://towardsdatascience.com/model-agnostic-meta-learning-maml-8a245d9bc4ac</a></li><li>【paper】Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks <a href="https://arxiv.org/pdf/1703.03400.pdf">https://arxiv.org/pdf/1703.03400.pdf</a></li><li>【论文翻译】Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks <a href="https://blog.csdn.net/weixin_40523230/article/details/85005378">https://blog.csdn.net/weixin_40523230/article/details/85005378</a></li><li>【video】MAML: Model-Agnostic Meta-Learning <a href="https://youtu.be/IkDw22a8BDE">https://youtu.be/IkDw22a8BDE</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Meta Learning </category>
          
          <category> Object Detection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Meta-Learning </tag>
            
            <tag> Object Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DiMP</title>
      <link href="/2020/05/18/dimp/"/>
      <url>/2020/05/18/dimp/</url>
      
        <content type="html"><![CDATA[<h1 id="learning-discriminative-model-prediction-for-trackingdimp"><a class="markdownIt-Anchor" href="#learning-discriminative-model-prediction-for-trackingdimp"></a> Learning Discriminative Model Prediction for Tracking【DiMP】</h1><blockquote><p><img src="/2020/05/18/dimp/image-20200509205838642.png" alt="image-20200509205838642"></p><p>📄 paper: <a href="https://arxiv.org/pdf/1904.07220.pdf">https://arxiv.org/pdf/1904.07220.pdf</a></p><p>💻 code: <a href="https://github.com/visionml/pytracking">https://github.com/visionml/pytracking</a></p><p>🌟  ICCV 2019 Oral <a href="https://www.bilibili.com/video/BV1zJ411t7Kb">https://www.bilibili.com/video/BV1zJ411t7Kb</a></p></blockquote><a id="more"></a><h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h1><p>​Our architecture is derived from <strong>a discriminative learning loss</strong> by designing a dedicated optimization process that is capable of predicting a powerful model in only a few iterations. Furthermore, our approach is able to learn key aspects of the discriminative<br>loss itself.</p><p>[ ▶running at over 40 FPS]</p><p>单卡GTX 1080</p><ul><li><p>57FPS ⚡ ResNet-18 as backbone</p></li><li><p>43FPS ⚡ ResNet-50 as backbone</p></li></ul><blockquote><p>什么是discriminative learning？</p><p>可以有效地利用背景信息的方法。</p></blockquote><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p>Siamese系列的三大缺点：</p><ol><li>Siamese的网络框架一般都只是把模板割出来，忽略了背景信息的利用，而背景的信息对目标的检测定位也是至关重要的；【判别性学习loss】</li><li>因为跟踪一般都是很多没有见过的类，通过offline学习的相似性度量可能不是很适用；【判别性学习loss+在线更新最速梯度下降法微调】</li><li>Siamese的框架没有一个合适的模型更新方式。【保留50个历史样本帧 + 每20帧使用两步最速下降法迭代微调target model f + 检测到distractor peak（干扰）时一步最速下降迭代】</li></ol><p>​we take inspiration from the discriminative learning procedures that have been successfully applied in recent trackers [26（MDNet）, 7（C-COT）, 4（ATOM）].</p><p>two key design choices:</p><ol><li>we employ a <strong>steepest descent</strong> based methodology that computes an optimal step length in each iteration.</li><li>we integrate a module that effectively initializes the target model.</li></ol><p>benchmark：</p><ul><li>NFS [9], UAV123 [24], OTB100 [37], TrackingNet [25], LaSOT [8], GOT10k [13] and VOT2018 [18]</li></ul><h1 id="2-related-work"><a class="markdownIt-Anchor" href="#2-related-work"></a> 2. Related Work</h1><p>Siamese系列</p><ul><li><p>SiamFC[1]：全卷积结构</p></li><li><p>RASNet[36]：residual attention mechanism（应用了注意力机制）</p><p>🏷 <a href="https://blog.csdn.net/uhrehjjbk/article/details/84862202">https://blog.csdn.net/uhrehjjbk/article/details/84862202</a></p><p>🏷 ​https://blog.csdn.net/weixin_40610037/article/details/80257287</p><blockquote><p><img src="/2020/05/18/dimp/20181206174550851.png" alt="img"></p><p>三种attention机制</p><p>1、 General Attention：（负责学习所有跟踪目标的共性）【利用先验知识】</p><p>在训练的时候得到的一个包含训练样本通用信息的特征图，得到不同的跟踪目标之间的共同的特征。一幅图的不同位置所表达的重要性不同， 该注意力机制要满足中心位置权重大于周围位置，比如高斯分布，实质是利用了目标在目标图像中心位置的先验知识。通过学习生成一个类似高斯框的结构，表征目标的空间信息（可理解为传统相关滤波中的期望的高斯响应的Map）。</p><p>2、 Residual Attention：（负责学习不同跟踪目标的差异性）【微调】</p><p>通过沙漏网络得到跟踪目标之间的差异的特征图。用于表征目标的语义信息，增加判别能力。</p><p>3、 Channel Attention：（负责是模型适应不同的contexts）【SENet】</p><p>经过卷积神经网络提取的特征通常包含多个通道channel，不同的通道得到的特征图不一样，每一层通道代表某种特定的模式信息。在不同场景下，不同通道可能具有不同的具有相异的显著性，通过通道注意力机制来选取对跟踪效果比较好的通道，剔除噪声通道。</p><p>4、weighted cross correlation</p><p>用加权相关滤波表示跟踪目标的特征，找到一个响应值最大的跟踪框。</p>  <img src="/2020/05/18/dimp/20181213172037983.png" alt="img" style="zoom:200%;"><p>Dual attention是Residual Attention和General Attention相加的结果，Dual Attention与Channel Attention进行加权相乘得到融合结果。</p></blockquote></li><li><p>SiamRPN[21]：RPN网络</p></li></ul><p>​Siamese系列的方法一个关键性的限制就是<strong>无法将背景区域信息或之前预测的帧信息有效地整合到模型预测中</strong>。DSiam[10]（动态孪生网络）学习特征的transformation来处理目标表观的变化和抑制背景。DaSiamRPN[40]在目标跟踪期间通过从目标模板中减去相应的图像特征来处理background distractors。（ ❓存疑，待看原文）</p><p>​另一类方法（MDNet、ECO、ATOM）通过在线学习一个discriminative classifier来从背景中区分目标。该类方法可以有效地应用背景信息，因此结果比较鲁棒。然而，这些方法依赖于更复杂的online learning procedure，<u>不易使用end-to-end学习模型来描述</u>。因此，这些方法经常是局限于从预训练的深度网络中提取特征。</p><p>​CFNet将CF的单样本闭式解整合到了深度网络中，但这个简单的CF模型缺乏判别力，效果比Siamese baseline差。RTINet在BACF Tracker中展开ADMM迭代，以在复杂的多阶段训练中学习特征提取器和一些超参数。但BACF模型仅限于傅里叶域CF公式的单样本变体，这样的公式无法利用多个样本，需要滤波器的特殊线性组合才能进行模型调整。Meta-tracker提出了将元学习运用到初始目标独立模型上，然后使用具有学习步长的梯度下降进行refine。但此策略仅适用于模型的初始适应，在以迭代方式应用时表现没有提高，因为模型不可能学习恒定的步长来达到既能快速的初始适应，又能optimal convergence。</p><blockquote><p>这句话是什么意思？</p></blockquote><p><img src="/2020/05/18/dimp/image-20200509214225790.png" alt="image-20200509214225790"></p><h1 id="3-method"><a class="markdownIt-Anchor" href="#3-method"></a> 3. Method</h1><p>两个理论基础：</p><ul><li>一个判别力强的损失函数可以指导网络学到鲁棒的特征</li><li>一个powerful的优化器可以加快网络收敛</li></ul><p>网络结构：（bbox estimation branch没有画出）</p><p><img src="/2020/05/18/dimp/image-20200509214300357.png" alt="image-20200509214300357"></p><p>​对bbox estimation分支采用ATOM中的overlap maximization based architecture。</p><p><img src="/2020/05/18/dimp/20190731160156261.png" alt="整体架构"></p><h2 id="31-discriminative-learning-loss"><a class="markdownIt-Anchor" href="#31-discriminative-learning-loss"></a> 3.1 Discriminative Learning Loss</h2><p>问题：</p><ol><li>简单地求差使模型过分关注负样本，而不是学习到强的判别能力。</li><li>没有解决目标和背景的不平衡问题。</li></ol><h2 id="32-optimization-based-architecture"><a class="markdownIt-Anchor" href="#32-optimization-based-architecture"></a> 3.2 Optimization-Based Architecture</h2><p><img src="/2020/05/18/dimp/image-20200509214353176.png" alt="image-20200509214353176"></p><p><img src="/2020/05/18/dimp/image-20200509214327720.png" alt="image-20200509214327720"></p><h1 id="4experiments"><a class="markdownIt-Anchor" href="#4experiments"></a> 4.Experiments</h1><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li><p>【精】【DiMP】Learning Discriminative Model Prediction for Tracking论文阅读 <a href="https://blog.csdn.net/sinat_31184961/article/details/89512108">https://blog.csdn.net/sinat_31184961/article/details/89512108</a></p></li><li><p>【精】DiMP:Learning Discriminative Model Prediction for Tracking <a href="https://blog.csdn.net/xwmwanjy666/article/details/98500578">https://blog.csdn.net/xwmwanjy666/article/details/98500578</a></p></li><li><p>【Oral翻译】<a href="https://www.bilibili.com/read/cv4053561">https://www.bilibili.com/read/cv4053561</a></p></li><li><p>[工程优化]共轭方向法(Conjugate direction method)的共轭梯度法(Conjugate gradient method)实现【附python代码】 <a href="https://blog.csdn.net/Shenpibaipao/article/details/89396983">https://blog.csdn.net/Shenpibaipao/article/details/89396983</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
          <category> IoU-Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoU-Net </tag>
            
            <tag> Siamese network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Siam R-CNN</title>
      <link href="/2020/05/01/siam-r-cnn/"/>
      <url>/2020/05/01/siam-r-cnn/</url>
      
        <content type="html"><![CDATA[<h1 id="siam-r-cnn-visual-tracking-by-re-detection"><a class="markdownIt-Anchor" href="#siam-r-cnn-visual-tracking-by-re-detection"></a> Siam R-CNN: Visual Tracking by Re-Detection</h1><blockquote><p><img src="/2020/05/01/siam-r-cnn/image-20200501141641949.png" alt="image-20200501141641949"></p><p>paper: <a href="https://arxiv.org/abs/1911.12836">https://arxiv.org/abs/1911.12836</a></p><p>TF code: <a href="https://github.com/VisualComputingInstitute/SiamR-CNN">https://github.com/VisualComputingInstitute/SiamR-CNN</a></p><p>project: <a href="http://www.vision.rwth-aachen.de/page/siamrcnn">http://www.vision.rwth-aachen.de/page/siamrcnn</a></p></blockquote><a id="more"></a><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p>​本文基于的范式是利用重检测进行视频目标追踪。前期利用重检测进行视觉目标追踪的方法通常会受到相似干扰物的影响，其解决策略主要是利用先前的预测提供强位置先验信息和模型在线更新，但是这两种方法都避免不了模型的漂移问题。</p><blockquote><p>什么是re-detect？</p></blockquote><p><strong>主要工作：</strong></p><ul><li>提出一种新的Siam R-CNN追踪器，利用孪生结构将Faster R-CNN应用于解决视觉目标追踪问题</li><li>提出一种新的<strong>难例挖掘方法</strong>，能有效缓解干扰物对追踪结果的影响</li><li>提出一种<strong>基于Tracklets的动态规划算法</strong>，能够在遮挡、目标消失等挑战中实现有效追踪</li></ul><p>​Siam R-CNN在六个短期追踪基准和四个长期追踪基准中均优于先前提出的方法。另外，利用现有的box-to-segmentation部件能够利用追踪框实现视频目标分割，在四个常见追踪数据集上比仅使用初始框标注进行分割的其他方法性能都好。</p><p><img src="/2020/05/01/siam-r-cnn/image-20200430211701696.png" alt="image-20200430211701696"></p><h1 id="2-related-work"><a class="markdownIt-Anchor" href="#2-related-work"></a> 2. Related Work</h1><p>​<strong>Visual Object Tracking (VOT)</strong>. VOT是在给定对象第一帧边界框的情况下完成视频目标追踪任务。 VOT通常根据基准进行评估，例如OTB [98，99]，年度VOT挑战[47，45]，以及更多[66，38，117，65，43]。 最近，已经提出了许多长期跟踪基准[62、86、23]，这些基准将VOT扩展到了更加困难和真实的设置，其中必须在许多帧上跟踪对象，并且对象会消失并重新出现。</p><p>​许多经典方法使用在线学习的分类器来重新检测整个图像上的感兴趣对象[1、28、2、76、30、77、42]。 相反，Siam R-CNN通过离线训练来学习预期的外观变化而不是在线学习分类器。</p><p>​像我们的Siam R-CNN一样，许多最新方法都使用Siamese体系结构来实现VOT。 孪生区域提议网络（SiamRPN [49]）使用单阶RPN [74]检测器，该检测器通过将深层模板特征与当前帧的深层特征互相关来重新检测模板目标。 在这里，单阶段意味着直接对锚定框anchor[57]进行分类，这与两阶段体系结构[74]相反，后者首先生成提案proposals，然后对齐其特征并在第二阶段对其进行分类。 最近的跟踪方法对SiamRPN进行了改进，使其能够应对相似物的干扰（DaSiamRPN [118]），或者添加了级联（C-RPN [25]），或者使用更深的网络架构（SiamRPN + [114]和SiamRPN ++ [ 48]），或者维护一组多样化的目标模板（THOR [78]）。 这些（还有更多[7，35，63]）仅在先前预测的小窗口内搜索对象。 DiMP [5]在遵循了这种范例的基础上使用元学习来学习鲁棒的目标和背景外观模型。</p><p>​VOT的其他最新发展包括使用在线学习的特定域层[67]，学习自适应空间滤波器正则化[17]，利用类别特定的语义信息[85]，使用连续[20]或分解[18]卷积以及实现精确的卷积，使用重叠预测网络的边界框预测[19]。Huang等学者 [39]提出了一种将任意一种检测器转换成跟踪器的框架。 像SiamR-CNN一样，它们也应用两阶段体系结构，但是它们的方法依赖于元学习，并且精度要低得多。</p><p>​当检测置信度较低时，主要通过扩大这些孪生跟踪器的搜索窗口来解决长期跟踪问题[118，48]。 相比之下，我们使用两阶孪生检测器来搜索整个图像，从而在许多基准测试中产生比当前方法更好的结果，尤其是对于长期跟踪而言。</p><p>Video Object Segmentation (VOS). VOS是VOT的扩展，其中提供了一组模板分割掩膜，并且需要在每个帧中生成分割掩膜。 许多方法都在模板掩膜的基础上进行微调[8、64、89、52、3、60]，这种方法可以产生非常好的分割结果，但是速度很慢。 最近，有几种方法在没有微调的情况下使用了第一帧掩膜[12、105、13、37、100、101、87、69]，运行速度更快，但通常效果不佳。<br>  有零星的几个的方法[94，108]解决仅在使用给定模板边界框而不使用掩膜的情况下产生掩膜跟踪结果的难题。 我们调整了在此设置中调整Siam R-CNN来解决VOS的任务，通过使用第二个网络为框跟踪结果生成掩膜。</p><h1 id="3-method"><a class="markdownIt-Anchor" href="#3-method"></a> 3. Method</h1><p>​受孪生跟踪器[45，99，47]成功的启发，我们将孪生架构用于重新检测器。 许多最新的跟踪器[118、94、48、49、5]采用单阶检测器架构。 对于单图像物体检测的任务，已显示出诸如Faster R-CNN [74]之类的两阶检测器网络优于单阶检测器。 受此启发，我们将跟踪器设计为孪生两阶检测网络。 第二阶段可以通过串联感兴趣区域（RoI）对齐的特征，直接将提议的感兴趣区域（RoI）与模板区域进行比较。</p><p>​通过将提议区域和参考图像对齐到相同的尺寸，Siam RCNN可以对对象尺寸和纵横比变化保持鲁棒性，而使用流行的互相关操作很难做到这一点[49]。 图2显示了包括Tracklet动态规划算法（TDPA）的Siam R-CNN的概述。</p><p><img src="/2020/05/01/siam-r-cnn/image-20200425132012693.png" alt="image-20200425132012693"></p><h2 id="31-siam-r-cnn"><a class="markdownIt-Anchor" href="#31-siam-r-cnn"></a> 3.1 Siam R-CNN</h2><p>​Siam R-CNN是基于两阶检测架构的孪生重检测器。 具体来说，我们采用了在COCO [56]数据集上经过预训练的用于检测80个对象类别的Faster R-CNN网络。</p><p>​ 该网络由骨干特征提取器和随后的两个检测阶段组成。 首先是与类别无关的RPN，然后是用于特定于类别的检测头。 我们固定骨干网和RPN的权重，并用我们的重检测头替换类别特定的检测头。我们通过执行RoI Align [33]为该建议区域提取深层特征，为RPN建议的每个区域的重检测头创建输入特征。我们还在第一帧中获取了初始化边界框的RoI Aligned深层特征，然后将它们串联在一起，并将合并的特征馈入1×1卷积中，这将特征通道的数量减少了一半。 然后将这些聚合特征送入带两个输出类别的重检测头中：拟议的区域要么是参考目标，要么不是。</p><p>​我们的检测头使用三级级联[9]，没有共享权重。 重新检测头的结构与Faster R-CNN的检测头的结构相同，不同之处在于仅使用两个输出类，并且通过串联创建重检测头的输入特征。 将主干和RPN参数冻结，并且使用视频数据集中的成对帧仅对重检测头（连接后）进行跟踪训练。 在这里，将一帧中的对象用作参考，并训练网络来重新检测另一帧中的同一对象。</p><h2 id="32-video-hard-example-mining"><a class="markdownIt-Anchor" href="#32-video-hard-example-mining"></a> 3.2 Video Hard Example Mining</h2><p>​在常规的Faster R-CNN训练期间，从目标图像中RPN提议的区域中采样第二阶段的负训练样本。 但是，在许多图像中，只有很少的相关负样本。 为了最大程度地提高重检测头的判别能力，我们需要在严格的负样本上进行训练。 在以前的工作中已经探索了进行检测的难例挖掘（例如[26，79]）。 但是，与寻找用于检测的通用难例挖掘方法不同，我们通过从其他视频中检索参考对象来构建困难训练样本。</p><h3 id="1-embedding-network"><a class="markdownIt-Anchor" href="#1-embedding-network"></a> (1) Embedding Network</h3><blockquote><p>这个Embedding Network网络其实就是一个特征提取网络，提取ground truth bbox图像区域的特征，用这个特征代表这块图像对象。因为提取的是代表特征，所以它应该具有同一对象的特征距离会很近，而不同对象的特征之间的距离会很远。</p></blockquote><p>​为当前视频建构难例的一个直观方法是选择相关的视频，这些视频里有和当前目标相同的类别[118]。 但是，对象类别标签并不总是可用，并且同一类的某些对象可能易于区分，而不同类的某些对象也可能是难例。</p><p>​因此，我们建议使用embedding network，它是受<mark>行人重识别</mark>启发的，该网络为该对象外观的每个GT边界框提取一个嵌入向量来代表这个对象。 我们使用来自PReMVOS [60]的网络，该网络使用batch-hard triplet loss[36]，先在COCO的各个类别上进行训练，然后再在YouTube-VOS上进行训练以消除各个对象实例之间的歧义。 例如，在嵌入空间中，两个不同的对象应该相距较远，而不同帧中的同一对象之间距离应相近。</p><blockquote><p>怎么消除歧义？</p></blockquote><blockquote><p><strong>MS COCO</strong> <a href="http://cocodataset.org/#home">http://cocodataset.org/#home</a></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501085453272.png" alt="image-20200501085453272"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501085601130.png" alt="image-20200501085601130"></p><p><strong>YouTube-VOS</strong> <a href="https://youtube-vos.org/">https://youtube-vos.org/</a></p><ul><li>4000+ high-resolution YouTube videos</li><li>90+ semantic categories</li><li>7800+ unique objects</li><li>190k+ high-quality manual annotations</li><li>340+ minutes duration</li></ul><p><img src="/2020/05/01/siam-r-cnn/image-20200501085541966.png" alt="image-20200501085541966"></p></blockquote><h3 id="2-index-structure"><a class="markdownIt-Anchor" href="#2-index-structure"></a> (2) Index Structure</h3><p>​接下来，我们构建了类似最近邻查询结构，创建了有效的索引结构，并使用它在嵌入空间中找到被跟踪对象的最近邻 （可能是被追踪对象的 困难样例） 。 图3示出了所检索的难例负例的例子。 可以看出，大多数负例都是非常相关和很难差别。</p><p><img src="/2020/05/01/siam-r-cnn/image-20200501101651228.png" alt="image-20200501101651228"></p><h3 id="3-training-procedure"><a class="markdownIt-Anchor" href="#3-training-procedure"></a> (3) Training Procedure</h3><blockquote><p>Embedding Network 和 Index Structure 都是为了Training Procedure中提供更高效的训练难例提取而设计的。</p><p>大致的思路就是，先提取每个真值追踪框的ROI aligned特征，然后在训练的过程中，由Index Structure生成选取的追踪对象的难例，完成训练。这里的难例与追踪对象是非常相似的，这种训练方法应该是可以提高网络对同类的不同实例的差别能力。</p></blockquote><p>​从其他视频中在线评估主干网络来检索当前视频帧的难例是非常昂贵的。 取而代之的是，我们为训练数据的GT真实框预先计算了与RoI对齐的特征。 对于每个训练步骤，通常会选择一个随机视频和该视频中的对象，然后选择一个随机参考图像和一个随机目标帧。 然后，我们使用索引结构从其他视频中为参考框检索10,000个最近邻的边界框，并从其中采样100个作为难例。 可以在补充材料中找到有关视频难例挖掘的更多详细信息。</p><h2 id="33-tracklet-dynamic-programming-algorithm核心"><a class="markdownIt-Anchor" href="#33-tracklet-dynamic-programming-algorithm核心"></a> 3.3 Tracklet Dynamic Programming Algorithm【核心】</h2><p>​我们的Tracklet动态规划算法（TDPA）隐式跟踪感兴趣的对象和潜在的干扰对象，因此干扰对象可以始终被抑制。 为此，TDPA维护一组tracklets，就是一个短的检测序列（short sequences of detections），几乎可以确定tracklets中的检测序列是属于同一对象的。 然后，它使用基于得分的动态规划算法为第一帧和当前帧中的模板对象选择tracklets中最有可能的序列。</p><blockquote><p>所以，TDPA选择的是tracklets中得分最高的一个检测序列</p></blockquote><p>​每个检测都由边界框、重检测得分及其RoI对齐特征进行定义。 此外，每个检测都是一个tracklets的一部分。 一个tracklet具有开始时间和结束时间，它由一组检测定义，从开始到结束时间的每个时间步都进行一次检测。也就是，一个tracklet中不允许有时间间隔。</p><p><img src="/2020/05/01/siam-r-cnn/image-20200501102156111.png" alt="image-20200501102156111"></p><h3 id="1-tracklet-building"><a class="markdownIt-Anchor" href="#1-tracklet-building"></a> (1) Tracklet Building</h3><p>​我们为第一帧GT边界框提取ROI对齐特征（ff_gt_feat），并初始化仅由该框组成的tracklet。对于每个新帧，我们按以下方式更新tracklet set（参见算法1）：</p><p>​我们提取当前帧的骨干特征，并评估区域提议网络（RPN）以获取感兴趣的区域（RoI，第2–3行）。为了补偿潜在的RPN误报，RoI的集合将由前一帧的边界框输出扩展。【应该是利用前一帧预测的bbox】</p><p>​我们在这些RoI上运行重新检测头（包括边界框回归），以生成一组对第一帧模板的重新检测（第4行）。 之后，我们在当前的检测<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><msub><mi>s</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">dets_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>上重新运行重检测头的分类部分（第6行），但是这次以来自前一帧的检测<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><msub><mi>s</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">dets_{t-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 作为参考，而不是第一帧GT真实框， 计算每对检测之间的相似性得分（分数）。</p><p>​为了测量两次检测的空间距离==【两次检测的空间距离，在追踪中的含义就是，前一帧的追踪框bbox和当前帧的追踪框bbox之间的距离）】==，我们用其中心坐标x和y表示其边界框，并用宽度w和高度h表示它们的宽度，其中x和w用图像宽度标准化，而y和h用图像高度标准化，所有值都在0到1之间。然后，通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi mathvariant="normal">∞</mi></msub></mrow><annotation encoding="application/x-tex">L_{\infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数给出两个边界框（x1，y1，w1，h1）和（x2，y2，w2，h2）之间的空间距离，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mn>1</mn><mo>−</mo><mi>x</mi><mn>2</mn><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mn>1</mn><mo>−</mo><mi>y</mi><mn>2</mn><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>w</mi><mn>1</mn><mo>−</mo><mi>w</mi><mn>2</mn><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>h</mi><mn>1</mn><mo>−</mo><mi>h</mi><mn>2</mn><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max(|x1-x2|,|y1-y2|,|w1-w2|,| h1-h2|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">2</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">h</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord">2</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。为了节省计算量并避免错误匹配，我们仅针对空间距离小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>的检测对计算成对相似度得分，否则将相似度得分设置为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span>。</p><p>​当与新检测的相似性得分高（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&gt;</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">&gt;\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>）并且没有歧义时，我们通过当前帧检测来扩展前一帧的tracklet（第7-20行）。例如没有其他检测具有与该tracklet相同强度的相似性（小于β），并且没有其他tracklet与该检测具有几乎相同的相似度（小于β）。 只要有任何歧义，我们都会启动一个新的tracklet，它最初包含一个检测。 然后在tracklet评分步骤中消除歧义。</p><blockquote><p>tracklet的扩张和新建的过程大致就是：</p><p>​当当前帧中可以明确检测到追踪目标时，就把这个检测加入到tracklet中，如果当前帧的检测结果有可能不是待追踪目标，那么就新那一个tracklet。就是在启动新tracklet的过程中，会自动隐式地追踪到相似干扰物，但是通过动态规划求解，可以求解出待追踪目标的tracklet序列。</p><p>​a是一个tracklet,tracklet是一个检测序列，A代表一个追踪，也是一个由tracklet组成的序列</p></blockquote><h3 id="2-scoring"><a class="markdownIt-Anchor" href="#2-scoring"></a> (2) Scoring</h3><p>​一个追踪<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A=(a_1,...,a_N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是由N个不重叠的tracklets组成的序列，例如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>&lt;</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>i</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">end(a_i)&lt;start(a_{i+1}),\forall i\in \{1,...,N-1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span> ，其中start和end表示tracklet的开始和结束时间。</p><blockquote><p>​这个式子表明，tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的结束时间，肯定在下一个tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 的开始时间之前。这也表明tracklet是一组时间上连续的检测。</p><p>​在长期追踪中它可以理解为，在目标的一个存在期间内，每帧检测结果（目标追踪框）的集合。而在长时追踪中，目标可以有多个存在期间，将这多个存在期间的tracklet组合起来，就是在整个视频中对这个目标的追踪A了。</p></blockquote><p>​总得分包含一个度量单独tracklets质量的一元得分和惩罚tracklets之间间空间跳跃的位置得分，例如：</p><p><img src="/2020/05/01/siam-r-cnn/image-20200501123523423.png" alt="image-20200501123523423"></p><p>​其中ff_score代表时间t时的tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的检测<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i,t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>重检测置信度 <mark>【也就还是检测置信度得分detection score】</mark> ，它来自于使用第一帧真值框作为参考的重检测头。总会有一个tracklet包含第一帧地面真值边界框，我们将其称为第一帧tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>f</mi><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ff}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>​一个tracklet中的所有检测detections，都有非常高的机会成为这个tracklet中的初始检测的正确继续 （是初始检测的一个追踪） ，因为有歧义的tracklets会被终止 。因此，对第一帧tracklet的最新检测也是几乎可以肯定是正确对象的最新观察结果。因此，我们还将最近检测到的第一帧tracklet用作重新检测的附加参考信息。这个得分表示为ff_tracklet_score，和ff_score进行线性组合。</p><p>​两个tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>之间的位置分数由最后一次检测<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的边界框<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>与第一次检测<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的边界框之差的负L1范数给出，即：</p><p><img src="/2020/05/01/siam-r-cnn/image-20200501123904078.png" alt="image-20200501123904078"></p><h3 id="3-online-dynamic-programming"><a class="markdownIt-Anchor" href="#3-online-dynamic-programming"></a> (3) Online Dynamic Programming</h3><p>​我们通过维护一个数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>来有效地找到具有最高总得分（等式1）的tracklet序列。数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>中每个tracklet a，存储从第一帧tracklet开始的到以a为结尾的最优tracklet序列的总得分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta [a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span>。</p><p>​一旦一个tracklet不被扩展了，它将被终止。 因此，对于每个新帧，仅需要重新计算已经扩展或新创建的tracklet的得分。对于一个新的时间步 【一个新的追踪任务？新的视频？】</p><p>​首先，我们将第一帧tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>f</mi><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ff}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>设置为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><msub><mi>a</mi><mrow><mi>f</mi><mi>f</mi></mrow></msub><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta[a_{ff}]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。之后，对于每个已经更新或新创建的tracklet a，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta[a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span>计算方式如下：</p><p><img src="/2020/05/01/siam-r-cnn/image-20200501135000807.png" alt="image-20200501135000807"></p><blockquote><p>​<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>~</mo></mover><mo>:</mo><mi mathvariant="normal">end</mi><mo>⁡</mo><mo stretchy="false">(</mo><mover accent="true"><mi>a</mi><mo>~</mo></mover><mo stretchy="false">)</mo><mo>&lt;</mo><mi mathvariant="normal">start</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tilde{a}:\operatorname{end}(\tilde{a})&lt;\operatorname{start}(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6678599999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">s</span><span class="mord mathrm">t</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span>表示的应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6678599999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span></span></span></span>是一个在a之前的tracklet，这个max求的是在a之前的tracklet中，得分的最大值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><mover accent="true"><mi>a</mi><mo>~</mo></mover><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta[\tilde{a}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span><span class="mclose">]</span></span></span></span>。</p><p>​整个动态规划方程就是，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta[a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span>等于tracklet a的重检测质量得分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">unary</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{unary}(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">u</span><span class="mord mathrm">n</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">y</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span>加上tracklet a之前的tracklet得分的最大值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><mover accent="true"><mi>a</mi><mo>~</mo></mover><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta[\tilde{a}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，再加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6678599999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span></span></span></span>和a之间的加权位置得分。</p></blockquote><p>​为了在很长的序列中保持效率，我们允许两个tracklet之间的最大时间间隔为1500帧，这对于大多数应用来说足够长。</p><p>​在当前帧中更新θ之后，我们选择动态规划得分最高的tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mi mathvariant="normal">＝</mi><mi>arg</mi><mo>⁡</mo><msub><mo><mi>max</mi><mo>⁡</mo></mo><mi>a</mi></msub><mi>θ</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\hat a ＝ \arg \max _a \theta[a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mord cjk_fallback">＝</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">ar<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span>。 如果选定的tracklet $\hat{a} $在当前帧中不包含一个检测，则我们的算法表明该对象不存在 （目标出视野或被完全遮挡） 。 对于需要在每个帧中进行预测的基准，我们使用所选tracklet的最新框，并将其分配为0。</p><h3 id="34-box2seg"><a class="markdownIt-Anchor" href="#34-box2seg"></a> 3.4 Box2Seg</h3><p>​为了为VOS任务生成分割掩膜，我们使用了来自PReMVOS [60]的现成的边界框到分割（Box2Seg）网络。 Box2Seg是具有Xception-65 [16]主干的全卷积DeepLabV3 + [11]网络。 它已经在Mapillary [68]和COCO [56]上受过训练，可以为边界框输出掩膜。 Box2Seg速度很快，在跟踪之后运行它只需每帧每个对象0.025秒。 我们组合重叠的掩膜，以使像素较少的掩膜位于顶部。</p><h1 id="4-experiments"><a class="markdownIt-Anchor" href="#4-experiments"></a> 4. Experiments</h1><p><img src="/2020/05/01/siam-r-cnn/image-20200501140213541.png" alt="image-20200501140213541"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140233721.png" alt="image-20200501140233721"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140259468.png" alt="image-20200501140259468"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140333522.png" alt="image-20200501140333522"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140402743.png" alt="image-20200501140402743"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140430142.png" alt="image-20200501140430142"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140449130.png" alt="image-20200501140449130"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140515651.png" alt="image-20200501140515651"></p><p>（1）Box2Seg部件。</p><p>​Box2Seg部件是来自于PReMVOS[60]的现成的边界框到分割掩膜（Box2Seg）网络。Box2Set是以Xception-65为主干的全卷积DeepLabV3+网络。它已经在Maplillary和COCO上进行过训练，转换速度很快，在追踪之后，每个对象只需要增加0.025秒，便可以将边界框输出为分割掩膜。<br>（2）tracklet到底是个什么样的东西？完全没有一个直观的形象。</p><p>​一个追踪<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A=(a_1,...,a_N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是由N个不重叠的tracklets组成的序列，例如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>&lt;</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>i</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">end(a_i)&lt;start(a_{i+1}),\forall i\in \{1,...,N-1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>，其中start和end表示tracklet的开始和结束时间。 这个式子表明，tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的结束时间，肯定在下一个tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 的开始时间之前。这也表明tracklet是一组时间上连续的检测。在长期追踪中它可以理解为，在目标的一个存续期间内的每帧检测结果（目标追踪框）的集合。而在长时追踪中，目标可以有多个存续期间，将这多个存续期间的tracklets组合起来，就是在整个视频中对这个目标的追踪A了。</p><blockquote><p>作者在文中说有很好的抗漂移性，可以在消失后轻松地重新检测目标。怎么实现的？</p></blockquote><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>【精】Siam R-CNN: Visual Tracking by Re-Detection 论文学习 <a href="https://blog.csdn.net/PAN_Andy/article/details/104473156">https://blog.csdn.net/PAN_Andy/article/details/104473156</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> Faster RCNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Siamese-Cascaded-RPN</title>
      <link href="/2020/03/16/siamese-cascaded-rpn/"/>
      <url>/2020/03/16/siamese-cascaded-rpn/</url>
      
        <content type="html"><![CDATA[<h1 id="siamese-cascaded-region-proposal-networks-for-real-time-visual-tracking笔记"><a class="markdownIt-Anchor" href="#siamese-cascaded-region-proposal-networks-for-real-time-visual-tracking笔记"></a> Siamese Cascaded Region Proposal Networks for Real-Time Visual Tracking笔记</h1><blockquote><p>MATLAB code： <a href="https://bitbucket.org/hengfan/crpn">https://bitbucket.org/hengfan/crpn</a></p><p>author: Heng Fan, Haibin Ling∗<br><em>Department of Computer and Information Sciences, Temple University, Philadelphia, PA USA</em></p></blockquote><a id="more"></a><h1 id="1-问题和动机"><a class="markdownIt-Anchor" href="#1-问题和动机"></a> 1. 问题和动机</h1><p>Siamese RPN：</p><blockquote><p><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Li_High_Performance_Visual_CVPR_2018_paper.pdf">High Performance Visual Tracking with Siamese Region Proposal Network(CVPR2018)</a></p><h6 id><a class="markdownIt-Anchor" href="#"></a> <img src="/2020/03/16/siamese-cascaded-rpn/1.jpg" alt></h6><p><img src="/2020/03/16/siamese-cascaded-rpn/2.jpg" alt></p></blockquote><p>之前的Siamese RPN存在一些问题：</p><ol><li><p>正负样本的比例不一致，导致Siamese Network 的训练不够有效；大部分的负样本都是简单样本，对最终的结果贡献很小，所以，在出现相似物体的时候，经常会出现跟踪混淆。</p></li><li><p>只有High-Level sematic feature，Low-level spatial features并没有充分的被探索。</p></li><li><p>One-stage Siamese RPN采用单个回归器进行物体的定位，但是实际上并没有很好的处理跟踪中物体的尺寸变换的问题。利用预先定义好的 Coarse anchor Box不能很好的进行精确的定位。</p></li></ol><p>​本文作者引入多级RPN网络（cascading a sequence of RPNs），来解决样本不平衡问题（imbalance problem），同时选择Hard Negative Samples来改善网络鲁棒性，并且还引入多层特征的融合，得到最后更好的特征表达。</p><h1 id="2-网络结构"><a class="markdownIt-Anchor" href="#2-网络结构"></a> 2. 网络结构</h1><h2 id="21-整体结构"><a class="markdownIt-Anchor" href="#21-整体结构"></a> 2.1 整体结构</h2><p><img src="/2020/03/16/siamese-cascaded-rpn/3.jpg" alt="整体结构"></p><p>​Siamese Cascaded RPN由两个部分的网络构成，第一个部分是Siamese Network（中文译为孪生网络），第二个部分是Cascaded Region Proposal Network。</p><h2 id="22-siamese-network"><a class="markdownIt-Anchor" href="#22-siamese-network"></a> 2.2 Siamese Network</h2><p>​作者采用了modified AlexNet来开发该部分网络。网络的两个分支是共享参数的，确保对x和z做相同的变换，这对于后续的similarity metric learning很重要。</p><h2 id="23-cascaded-rpn"><a class="markdownIt-Anchor" href="#23-cascaded-rpn"></a> 2.3 Cascaded RPN</h2><p>​前人的方法大部分都忽略了 class imbalance 的问题，导致在出现相似性物体的时候，效果不佳。此外，他们也仅用 high-level semantic features 来进行跟踪，而很少考虑 multi-level feature。为了解决上述这两个问题，本文提出多阶段的跟踪方法，网络结构细节如下：</p><p><img src="/2020/03/16/siamese-cascaded-rpn/4.jpg" alt="Cascaded RPN"></p><p>​对于每一个阶段的 RPN，其利用 FTB 模块来融合来自第l个 convolutional layer的特征以及high-level feature，融合后的特征可以用下面的公式进行表达：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mi>T</mi><mi>B</mi><mo stretchy="false">(</mo><msub><mi mathvariant="normal">Φ</mi><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi_l(z) = FTB(\Phi_{l-1}(z),\varphi_l(z))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mi>T</mi><mi>B</mi><mo stretchy="false">(</mo><msub><mi mathvariant="normal">Φ</mi><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi_l(x) = FTB(\Phi_{l-1}(x),\varphi_l(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><h3 id="231-ftb"><a class="markdownIt-Anchor" href="#231-ftb"></a> 2.3.1 FTB</h3><p>再看看整体结构</p><p><img src="/2020/03/16/siamese-cascaded-rpn/3.jpg" alt="整体结构"></p><p>​其中的FTB：feature transfer block结构如下：</p><p><img src="/2020/03/16/siamese-cascaded-rpn/5.jpg" alt="FTB"></p><p>​</p><p>​主要是对较低分辨率的图像利用Deconvlutional layer 进行升分辨率处理，得到特征卷积后，与另外一支进行元素集相加（element-wise summarize）得到最终的结果。</p><p>​对于RPN-1来说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi_1(z)=\varphi_l(z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>φ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi_1(x)=\varphi_1(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，文中的multi-stage指的就是存在多个RPN网络。</p><blockquote><p>引用：目标检测中one-stage和two-stage方法的区别就在于有没有RPN。</p></blockquote><p>​对于stage l，计算每一个anchor的分类得分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msubsup><mi>c</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{c_i^l\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>和regression offsets <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msubsup><mi>r</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{r_i^l\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>（回归偏移量），计算公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msubsup><mi>c</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo><mo>=</mo><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">]</mo><mrow><mi>c</mi><mi>l</mi><mi>s</mi></mrow></msub><mo separator="true">,</mo><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">]</mo><mrow><mi>c</mi><mi>l</mi><mi>s</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\{c_i^l\} = corr([\Phi_l(z)]_{cls},[\Phi_l(x)]_{cls})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1491079999999998em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mopen">[</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msubsup><mi>r</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo><mo>=</mo><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">]</mo><mrow><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub><mo separator="true">,</mo><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">]</mo><mrow><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\{r_i^l\} = corr([\Phi_l(z)]_{reg},[\Phi_l(x)]_{reg})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1491079999999998em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mopen">[</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>​where$ [Φ_l (z)]<em>{cls}，[Φ_l(x)]</em>{cls} , [Φ_l (z)]_{reg}$ and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">]</mo><mrow><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[Φ_l (x)]_{reg}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> are<br>derived by performing convolutions on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Φ_l (z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Φ_l (x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>.</p><p>​我们用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">A_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示在阶段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>的anchor set。根据分类的得分，我们可以过滤掉该集合中negative confidence 大于预先设定的阈值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>的样本。然后，剩下的样本就构成了新的anchor set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{l+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，并且用于训练<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>P</mi><msub><mi>N</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">RPN_{l+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>。此外，为了提供更好的初始化，我们优化了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{l+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 中 anchor的center location以及size，所以产生了更加准确的定位。</p><h3 id="232-loss-function"><a class="markdownIt-Anchor" href="#232-loss-function"></a> 2.3.2 Loss Function</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>P</mi><msub><mi>N</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">RPN_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的损失函数为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">ℓ</mi><mrow><mi>R</mi><mi>P</mi><msub><mi>N</mi><mi>l</mi></msub></mrow></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><msubsup><mi>c</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><msubsup><mi>r</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><mrow><msub><mi>L</mi><mrow><mi>c</mi><mi>l</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>c</mi><mi>i</mi><mi>l</mi></msubsup><mo separator="true">,</mo><msubsup><mi>c</mi><mi>i</mi><msup><mi>l</mi><mo>∗</mo></msup></msubsup><mo stretchy="false">)</mo><mo>+</mo><mi>λ</mi><munder><mo>∑</mo><mi>i</mi></munder><msubsup><mi>c</mi><mi>i</mi><msup><mi>l</mi><mo>∗</mo></msup></msubsup><msub><mi>L</mi><mrow><mi>l</mi><mi>o</mi><mi>c</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>r</mi><mi>i</mi><mi>l</mi></msubsup><mo separator="true">,</mo><msubsup><mi>r</mi><mi>i</mi><msup><mi>l</mi><mo>∗</mo></msup></msubsup><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\ell_{RPN_l}(\{c_i^l\},\{r_i^l\})=\sum_i {L_{cls}(c_i^{l},c_i^{l^*})+\lambda\sum_i c_i^{l^*} L_{loc}(r_i^l,r_i^{l^*})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1549679999999998em;vertical-align:-0.25586em;"></span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9473399999999998em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9473399999999998em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9473399999999998em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p><p>​其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>r</mi><mi>i</mi><msup><mi>l</mi><mo>∗</mo></msup></msubsup></mrow><annotation encoding="application/x-tex">r_i^{l^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1560039999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8973399999999999em;"><span style="top:-2.441336em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>表示 anchor i 和GT之间的true distance（真实距离？）。服从前人工作，作者也将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>r</mi><mi>i</mi><msup><mi>l</mi><mo>∗</mo></msup></msubsup></mrow><annotation encoding="application/x-tex">r_i^{l^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1560039999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8973399999999999em;"><span style="top:-2.441336em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>设置为 4d 向量，如下所示：</p><p><img src="/2020/03/16/siamese-cascaded-rpn/6.jpg" alt="true distance"></p><p>​其中，x, y, w, h 是 BBox 的中心点及其宽高。与常规的固定anchor不同，C-RPN的anchors可以进行微调：</p><p><img src="/2020/03/16/siamese-cascaded-rpn/7.jpg" alt="anchors"></p><p>​对于第一个阶段的 anchor，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mi>a</mi><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>y</mi><mi>a</mi><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>w</mi><mi>a</mi><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>h</mi><mi>a</mi><mn>1</mn></msubsup></mrow><annotation encoding="application/x-tex">x^1_a,y^1_a,w^1_a,h^1_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>是预先设定的。</p><p>【注】此处关于损失函数讲的不是特别清晰，关于回归损失函数的定义，可以参考</p><ul><li><p><a href="http://papers.nips.cc/paper/5638-faster-r-cnn-towards-real-time-object-detection-with-region-proposal-networks.pdf">Faster RCNN paper</a></p></li><li><p><a href="https://blog.csdn.net/Mr_health/article/details/84970776">【Faster RCNN】损失函数理解</a></p></li></ul><blockquote><p>引用：Faster RCNN损失函数定义</p><p>Faster RCNN的的损失主要分为RPN的损失和Fast RCNN的损失，计算公式如下，</p><p><img src="https://img-blog.csdnimg.cn/20181108105638545.png" alt></p><p>并且两部分损失都包括分类损失（cls loss）和回归损失（bbox regression loss）。</p><ol><li><p>分类损失</p><ul><li><p>RPN分类损失（二分类交叉熵损失）</p><p>RPN网络的产生的anchor只分为前景和背景，前景的标签为1，背景的标签为0。</p></li><li><p>Fast RCNN分类损失（多分类交叉熵损失）</p></li></ul></li><li><p>回归损失</p></li></ol></blockquote><h3 id="233-总结"><a class="markdownIt-Anchor" href="#233-总结"></a> 2.3.3 总结</h3><p>​上述过程构成了所提出的级联RPN（C-RPN）。其最终的损失函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>C</mi><mi>R</mi><mi>P</mi><mi>N</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{CRPN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是各个RPN损失函数的和：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">ℓ</mi><mrow><mi>C</mi><mi>R</mi><mi>P</mi><mi>N</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>L</mi></munderover><msub><mi mathvariant="normal">ℓ</mi><mrow><mi>R</mi><mi>P</mi><msub><mi>N</mi><mi>l</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">\ell_{CRPN}=\sum_{l=1}^L \ell_{RPN_l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1304490000000005em;vertical-align:-1.302113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span></span></span></span></span></p><h1 id="3-算法流程"><a class="markdownIt-Anchor" href="#3-算法流程"></a> 3. 算法流程</h1><p><img src="/2020/03/16/siamese-cascaded-rpn/8.jpg" alt="Algorithm"></p><h1 id="4-experiments"><a class="markdownIt-Anchor" href="#4-experiments"></a> 4. Experiments</h1><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221604131.png" alt="image-20200306221604131"></p><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221627393.png" alt="image-20200306221627393"></p><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221642822.png" alt="image-20200306221642822"></p><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221706307.png" alt="image-20200306221706307"></p><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221738139.png" alt="image-20200306221738139"></p><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221800658.png" alt="image-20200306221800658"><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221817134.png" alt="image-20200306221817134"></p>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
          <category> RPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> RPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ATOM</title>
      <link href="/2020/03/06/atom/"/>
      <url>/2020/03/06/atom/</url>
      
        <content type="html"><![CDATA[<h1 id="atom-accurate-tracking-by-overlap-maximization-笔记"><a class="markdownIt-Anchor" href="#atom-accurate-tracking-by-overlap-maximization-笔记"></a> ATOM : Accurate Tracking by Overlap Maximization 笔记</h1><ul><li>Paper：<a href="https://arxiv.org/pdf/1811.07628">https://arxiv.org/pdf/1811.07628</a></li><li>Code: <a href="https://github.com/visionml/pytracking">https://github.com/visionml/pytracking</a></li></ul><a id="more"></a><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1. 简介</h1><p>tracking problem可以拆分为两个任务：</p><ul><li>classification</li><li>estimation</li></ul><blockquote><p>问题：是否类似于two-stage目标检测，如Faster RCNN?</p></blockquote><h2 id="11-target-estimationofflineiou-predictor"><a class="markdownIt-Anchor" href="#11-target-estimationofflineiou-predictor"></a> 1.1 target estimation（offline，IoU-predictor）</h2><blockquote><p>通过一个bbox来预测目标的状态。?</p></blockquote><p>四个输入：</p><ul><li>当前视频帧的feature</li><li>当前视频帧预测的bounding box</li><li>reference image的feature</li><li>reference image的目标bounding box</li></ul><p>一个输出：</p><ul><li>当前视频帧bbox的IoU预测得分</li></ul><h2 id="12-target-classificationonlineiou-modulation"><a class="markdownIt-Anchor" href="#12-target-classificationonlineiou-modulation"></a> 1.2 target classification（online，IoU-Modulation）</h2><blockquote><p>粗略地将要提取的图像块分为前景和背景，得到一个粗略的目标位置。（）</p></blockquote><p>​用于对提取的proposal进行打分，进行前景和背景的划分。作者采用了基于Conjugate Gradient and  Gauss-Newton的优化策略，替代梯度下降法，可以保证fast online training。</p><h2 id="13-related-work"><a class="markdownIt-Anchor" href="#13-related-work"></a> 1.3  Related Work</h2><p>axis aligned， rotated，</p><p>target classification:</p><ul><li>使用在线训练强分类器来判别，correlatio-based tracker（圆形卷积的对角化变换）</li></ul><p>target estimation:</p><ul><li><p>brute-force multi-scale detection strategy</p></li><li><p>预测bbox是一个complex task，需要目标的high-level a-prior knowledge，近期的方法集中在整合先验知识到离线学习中。</p></li><li><p>SiamRPN，Siamese tracking approaches，缺点是没有在线学习、明确考虑干扰因素，不过也使用了简单的模板更新技术部分解决该问题。</p></li></ul><h1 id="2-网络结构"><a class="markdownIt-Anchor" href="#2-网络结构"></a> 2. 网络结构</h1><h2 id="21-整体架构"><a class="markdownIt-Anchor" href="#21-整体架构"></a> 2.1 整体架构</h2><p><img src="/2020/03/06/atom/20190731160156261.png" alt="整体架构"></p><p>​目标估计和分类任务都使用相同的backbone ResNet-18（pretrained ImageNet，no fine-tuning）</p><blockquote><p>问题：什么是backbone?</p><p>​分类网络中去掉分类器或全连接层的部分，就被成为backbone，即网络的主要结构。</p></blockquote><p>​将当前帧的图片（以及GT）输入到backbone提取特征，得到了Modulation vector，接下来test image也输入到backbone中提取特征，然后将layer 3层的特征经过分类模块（classifier，trained online），预测目标的一个置信度分数（positive coefficients），从而得到一个粗略的BB estimates（位置和宽高）。</p><p>​接着与第一帧得到的Modulation vector进行点乘，根据之前帧得到的粗略的bbox然后随机生成10个bbox，送到目标估计模块（在大量数据上离线训练好的），通过最大化IoU来refine bbox（取iou最高的三个求平均）。</p><blockquote><p>当然在跟踪的时候IoU-Net是不更新的，只更新分类的两层，这部分代码体现在初始化IoU-Net的时候atom.py中的<code>def init_iou_net()</code>方法中的``p.requires_grad=False<code>另外在</code>pytrakcing/utils/loading中net, _ = ltr_loading.load_network(path_full, backbone_pretrained=False)`说明backone不采用预训练模型，而在训练的时候backbone加载的是预训练模型。</p></blockquote><p>​其次，原来的IoU-Net是针对class-special的，而跟踪针对于任意类都可以。所以，利用了第一帧目标的标注信息，获取targe-specific信息，从而得到相应的IoU predictions。因此在跟踪时，给定第一帧的信息很重要，那怎么可以有效利用呢？</p><p>​本文试着和当前帧的特征融合，但是效果很差，最后提出了 modulation-base network架构来预测任意物体的IoU。我觉得这里是作为一个先验条件的，具体的目标估计网络（训练框架）如下：</p><p><img src="/2020/03/06/atom/8.jpg" alt></p><p>​该网络包含两个分支：reference branch和test branch，两个分支都是依赖于ResNet-18 Block 3和ResNet-18 Block 4的feature作为输入。</p><blockquote><p>【补充】</p><p>​追踪针对的目标类别是未知的，而检测问题是依赖于每个类别上的检测。</p><blockquote><p>论文说原有的IoU-Net是class-specific的，原因就在于此。</p></blockquote><p>​但仍需要class-specific IoU predictor来对每一帧进行分析得到high-level nature。因为这个训练过程太费时，故而采用offline training来学习general representation用于IoU predictor。</p></blockquote><h3 id="211-reference-branch"><a class="markdownIt-Anchor" href="#211-reference-branch"></a> 2.1.1 Reference Branch</h3><p>由一个卷积层后接PrPool层和全连接层组成。</p><p><img src="/2020/03/06/atom/9.jpg" alt="Reference Branch"></p><ul><li><p>input</p><p>Feature <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and the target bbox annotation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">B_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in the reference image.</p></li><li><p>output</p><p>Modulation Vector <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>B</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(x_0,B_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，size：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn><mo>×</mo><msub><mi>D</mi><mi>z</mi></msub></mrow><annotation encoding="application/x-tex">1\times1\times D_z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li></ul><h3 id="212-test-branch"><a class="markdownIt-Anchor" href="#212-test-branch"></a> 2.1.2 Test Branch</h3><p>​The current image, in which we want to estimate the target bounding box, is processed through the <em>test branch</em>.</p><p>​ It first extracts a  <strong>deep representation</strong> by feeding the backbone features <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> through two convolutional layers followed by a <code>PrPool</code> with the bounding box estimate <em>B</em>.</p><p>​由两个卷积层，后接PrPool组成。</p><p><img src="/2020/03/06/atom/10.jpg" alt="Test Branch"></p><ul><li><p>input</p><p>backbone features <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>  （deep representation）</p></li><li><p>output</p><p>representation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">z(x, B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span> ，size​：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>×</mo><mi>K</mi><mo>×</mo><msub><mi>D</mi><mi>z</mi></msub></mrow><annotation encoding="application/x-tex">K\times K\times D_z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>where K is spatial output size of the PrPool layer</p></li></ul><h3 id="213-后续步骤"><a class="markdownIt-Anchor" href="#213-后续步骤"></a> 2.1.3 后续步骤</h3><p>​The computed feature representation of the test image is then <em>modulated</em> by the coefficient vector <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> via a <strong>channel-wise multiplication</strong>.</p><p>​This creates a target-specific representation for IoU prediction, effectively incorporating the reference appearance information. The modulated representation is finally fed to the IoU predictor module <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>, consisting of three fully connected layers. The predicted IoU of the bounding box <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> is hence given by</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>o</mi><mi>U</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>z</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">IoU(B)=g(c(x_0, B)\cdot z(x,B))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><blockquote><p>问题：不知道g是指哪部分？自己理解有无偏差？</p><p>回答：暂时无偏差。</p></blockquote><blockquote><p>问题：这两个branch各自对应了target estimation和target classification中的哪个部分？</p><p>回答：target estimation，负责估计目标的位置。</p></blockquote><h3 id="214-prpool参考"><a class="markdownIt-Anchor" href="#214-prpool参考"></a> 2.1.4 PrPool参考</h3><p>RoI Pooling/ RoI Align /PrRoI Pooling三者的区别：</p><p><img src="/2020/03/06/atom/20190731154944824.png" alt="区别"></p><p>参考文章：</p><ul><li><p><a href="https://everitt257.github.io/blog/2019/02/07/RoI-Explained.html">ROI pooling, align, warping</a></p></li><li><p><a href="https://blog.csdn.net/discoverer100/article/details/90519423">Precise RoI Pooling（PrRoI Pooling）笔记</a></p></li><li><p><a href="https://blog.csdn.net/m_buddy/article/details/85110124">RoI Pooling与RoIWrap Pooling与RoIAlign Pooling与Precise RoI Pooling</a></p></li><li><p><a href="https://blog.csdn.net/u011436429/article/details/80279536">ROI Pooling原理及实现</a></p></li><li><p><a href="https://blog.csdn.net/u011436429/article/details/80277633">Selective Search原理及实现</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/ro0lG3uMUPYNZA9rM3I_YQ">目标检测算法中检测框合并策略技术综述</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/47384261">IoUNet(7)_源码 PrRoIPooling(1)</a></p></li><li><p><a href="https://github.com/vacancy/PreciseRoIPooling">PrePool code implements </a></p></li></ul><h2 id="22-模型训练"><a class="markdownIt-Anchor" href="#22-模型训练"></a> 2.2 模型训练</h2><h3 id="221-off-line-trainingtarget-estimation"><a class="markdownIt-Anchor" href="#221-off-line-trainingtarget-estimation"></a> 2.2.1 off-line training（target estimation？）</h3><p>训练数据集：</p><ul><li>LaSOT dataset（Large-scale Single Object<br>Tracking）</li><li>TrackingNet</li></ul><p>​在最大间隔为50的视频中采样图片对，同时用COCO数据集做数据增强，提取了目标周围的5倍大小的方形区域作为输入</p><blockquote><p>原文中为 From the reference image, we sample a square patch centered at the target, with an area of about <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>5</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">5^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> times the target area.</p></blockquote><p>​同时为了防止以目标为中心过拟合，在test image对position和scale做了抖动（perturbation）。</p><p>​因为没有分类层预测bbox，因此在训练的时候将test image的bbox真值通过增加高斯噪声做了扰动，产生了16 candidate bounding boxe，之后还使用image flipping and color jittering for data augmentation，从而输入到网络作为分类的结果。而test image的真值和扰动后的值做了IoU，从而作为loss进行训练。</p><blockquote><p>另外我们可以从优化器部分看到，训练的时候更新的是哪一块：<code>optimizer=optim.Adam(actor.net.bb_regressor.parameters(),lr=1e-3)</code>，也就是训练iounet那一部分。</p></blockquote><p><strong>训练参数设置：</strong></p><p>​The weights in our head network are initialized using<code>[12]</code>. For the backbone network, we freeze all weights during training. We use the mean-squared error loss function and train for 40 epochs with 64 image pairs per batch. The ADAM <code>[16]</code> optimizer is employed with initial learning rate of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mi mathvariant="normal">−</mi><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{−3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span> , and using a factor 0.2 decay every 15 epochs.</p><h3 id="222-online-trackingtarget-classification-by-fast-online-learning"><a class="markdownIt-Anchor" href="#222-online-trackingtarget-classification-by-fast-online-learning"></a> 2.2.2 online tracking（Target Classification by Fast Online Learning）</h3><p>​分类模型由两层全卷积网络组成，如公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">;</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>ϕ</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>w</mi><mn>2</mn></msub><mo>∗</mo><msub><mi>ϕ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo>∗</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x;w)=\phi_2 (w_2 * \phi_1 (w_1 * x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><ul><li><p>first layer：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mn>1</mn><mo>×</mo><mn>1</mn><mi mathvariant="normal">，</mi><mn>64</mn><mi mathvariant="normal">，</mi><msub><mi>w</mi><mn>1</mn></msub><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（1\times1，64，w_1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">6</span><span class="mord">4</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span></p></li><li><p>second layer：$（4\times4，1，w_2) $</p></li></ul><p>​x是backbone feature map，由于训练样本上得不到在线跟踪目标的信息，所以分类网络的head是在线训练的，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">w_1,w_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是网络参数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span>代表standard multi-channe convolution（多通道卷积）。</p><p><strong>Learning objective based on the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> classification error：</strong></p><p><img src="/2020/03/06/atom/11.jpg" alt="Learning objective"></p><p>​Each training sample feature map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> is annotated by the classification confidences <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>W</mi><mo>×</mo><mi>H</mi></mrow></msup></mrow><annotation encoding="application/x-tex">y_j \in \mathbb{R}^{W\times H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span></span>, set to a sampled Gaussian function centered at the target location. The impact of each training sample is controlled by the weight <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>γ</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">γ_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, while the amount of regularization on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">w_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is set by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">λ_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> .</p><p>​通常我们会应用标准的梯度下降或者随机梯度下降法(SGD)法求解，但是这些不适合于在线学习，因为收敛效率太慢。本文作者提出了将共轭梯度下降法与神经网络的反向传播结合起来的新方法。</p><h3 id="223-共轭梯度下降法conjugate-gradient"><a class="markdownIt-Anchor" href="#223-共轭梯度下降法conjugate-gradient"></a> 2.2.3 共轭梯度下降法（Conjugate Gradient）</h3><p>将上式列出的分类损失分为两个部分：</p><p><img src="/2020/03/06/atom/20190731213039188.png" alt></p><p><img src="/2020/03/06/atom/20190731213138893.png" alt></p><p>for j ∈ {1,…,m}, k = 1,2</p><p>所以最后的损失函数</p><p><img src="/2020/03/06/atom/11.jpg" alt="Learning objective"></p><p>​就可以写作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>r</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L(w)=||r(w)||^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> is the concatenation of all residuals <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r_j(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>.</p><p>利用<code>quadratic Gauss-Newton</code>（近似忽略二阶微分）近似得到:</p><p><img src="/2020/03/06/atom/20190731213639984.png" alt></p><p>进行一阶泰勒展开：</p><p><img src="/2020/03/06/atom/20190731213922510.png" alt></p><p>最终损失函数的公式可以化为：</p><p><img src="/2020/03/06/atom/20190731214021772.png" alt></p><p>​we have defined <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>w</mi></msub><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r_w = r(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>J</mi><mi>w</mi></msub><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>r</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">J_w=\frac{∂r}{∂w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> is the Jacobian of  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> at <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> （雅可比矩阵）.  The new variable <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∆</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">∆w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∆</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> represents the increment in the parameters <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>.</p><p>​我们需要的变量就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">Δw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>用于更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，可以直接对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">Δw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>求导，使用Conjugate Gradient(CG)方法来迭代。</p><p><img src="/2020/03/06/atom/12.jpg" alt></p><blockquote><p>问题：为什么论文中最后要求CG转化为了必须要求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>J</mi><mi>w</mi><mi>T</mi></msubsup><msub><mi>J</mi><mi>w</mi></msub><mi>p</mi></mrow><annotation encoding="application/x-tex">J^T_wJ_wp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.088331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">p</span></span></span></span> 的问题了呢？</p></blockquote><p>因为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi mathvariant="normal">∂</mi><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">(</mo><mi>w</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>r</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mi>T</mi></msup><mi>u</mi><mo>=</mo><msubsup><mi>J</mi><mi>w</mi><mi>T</mi></msubsup><mi>u</mi></mrow><annotation encoding="application/x-tex">\frac{\partial}{\partial w}(r(w)^Tu)=\frac{\partial r}{\partial w}^Tu = J_w^T u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.288671em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.602671em;"><span style="top:-3.8243400000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span></span></span></span></span></p><p>事实上可以整合在backpropagation procedure中。</p><p>其中：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>p</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>s</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>v</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">BackProp(s,v)=\frac{\partial s}{\partial v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>p</mi><mo stretchy="false">(</mo><msup><mi>r</mi><mi>T</mi></msup><mi>u</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>J</mi><mi>w</mi><mi>T</mi></msubsup><mi>u</mi></mrow><annotation encoding="application/x-tex">BackProp(r^Tu,w)=J^T_w u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span></span></span></span></span></p><h1 id="3-扩展-iou-net见iou-net"><a class="markdownIt-Anchor" href="#3-扩展-iou-net见iou-net"></a> 3. 扩展： IoU-Net【见<a href="https://soarkey.github.io/2020/03/02/iou-net/">IoU-Net</a>】</h1><blockquote><p>问题：本文中说IoU-Net是class-specific的，为什么？</p><p>对于一般的跟踪为什么不适合？</p><p>回答：原先的IoU-Net主要针对目标检测，物体类别已知，所以是class-specific的，而追踪问题针对的目标很难事先知晓，故而不适合。</p></blockquote><p>当前two-stage的目标检测任务流程：</p><ol><li>RPN找出一系列候选框，区分前景背景。</li><li>类置信度及回归坐标。</li><li>通过NMS，对分类置信度进行排序，过滤掉IoU大与一定阈值的框，得到最终的结果。</li></ol><p>这种方法可能会出现两个问题：</p><ol><li><p>在抑制重复检测时，由于定位置信度的缺失，分类分数通常被用作检测框排名的指标。在下图中，研究者展示了一组案例，其中有更高分类置信度的检测框却与其对应的目标物体有更小的重叠。就像 Gresham 著名的 “劣币驱逐良币”理论一样，分类置信度和定位准确度之间的不匹配可能导致定位更准确的边界框在 NMS 过程中反被更不准确的边界框抑制。</p><p><img src="/2020/03/06/atom/3.jpg" alt></p></li><li><p>缺乏定位置信度使得被广泛使用的边界框回归方法缺少可解释性或可预测性。举个例子，之前的研究报告了迭代式边界框回归的非单调性。也就是说，如果多次应用边界框回归，可能有损输入边界框的定位效果（见下图）。</p><p><img src="/2020/03/06/atom/4.jpg" alt></p></li></ol><h2 id="31-网络架构"><a class="markdownIt-Anchor" href="#31-网络架构"></a> 3.1 网络架构</h2><p><img src="/2020/03/06/atom/5.jpg" alt></p><blockquote><p>RPN (区域候选网络)：基于滑窗的无类别obejct检测器</p><p>详情见Faster RCNN</p><p><img src="/2020/03/06/atom/6.jpg" alt></p><p><img src="/2020/03/06/atom/7.jpg" alt></p></blockquote><h2 id="32-相关"><a class="markdownIt-Anchor" href="#32-相关"></a> 3.2 相关</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/41944858">旷视科技提出IoU-Net，让目标检测用上定位置信度</a></li><li><a href="https://arxiv.org/pdf/1807.11590v1.pdf">IoU-Net paper</a></li><li><a href="https://blog.csdn.net/JNingWei/article/details/78847696">RPN (区域候选网络)</a></li><li><a href="https://blog.csdn.net/ctfabc4425/article/details/81490805">论文笔记：(IOU-Net) Acquisition of Localization Confidence for Accurate Object Detection</a></li></ul><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4. 总结</h1><p>​知道了文章的大体思路，用了一些新的数据集来测评，借鉴目标检测的IoU-Net得到一个更精确的bbox，使用高斯牛顿优化方法，（求解非线性最小二乘问题时的一个特例，把黑森矩阵用雅克比矩阵代替，当然这个是有条件的），还是去跑代码吧！这样会有更深的理解。</p><p>​牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。</p><p>​高斯–牛顿迭代法的基本思想是使用泰勒级数展开式去近似地代替非线性回归模型，然后通过多次迭代，多次修正回归系数，使回归系数不断逼近非线性回归模型的最佳回归系数，最后使原模型的残差平方和达到最小。</p><h1 id="5-experiments"><a class="markdownIt-Anchor" href="#5-experiments"></a> 5. Experiments</h1><p><img src="/2020/03/06/atom/13.jpg" alt></p><p><img src="/2020/03/06/atom/14.jpg" alt></p><p><img src="/2020/03/06/atom/15.jpg" alt></p><p><img src="/2020/03/06/atom/16.jpg" alt></p><p><img src="/2020/03/06/atom/17.jpg" alt></p><h1 id="6-参考资料"><a class="markdownIt-Anchor" href="#6-参考资料"></a> 6. 参考资料</h1><ul><li><a href="https://blog.csdn.net/PNAN222/article/details/91049022">Pytracking代码运行笔记</a></li><li><a href="https://blog.csdn.net/xwmwanjy666/article/details/9775784">ATOM: Accurate Tracking by Overlap Maximization</a></li><li><a href="https://zhuanlan.zhihu.com/p/79355209">ATOM: Accurate Tracking by Overlap Maximization论文笔记</a></li><li><a href="https://www.cnblogs.com/wangxiaocvpr/p/10520522.html">论文笔记：ATOM: Accurate Tracking by Overlap Maximization</a></li><li><a href="https://zh.gluon.ai/chapter_convolutional-neural-networks/resnet.html">残差网络（ResNet）</a></li><li><a href="https://blog.csdn.net/qq547276542/article/details/78186050">共轭梯度法的推导与完整算法</a></li></ul><h1 id="7-代码解析无法运行"><a class="markdownIt-Anchor" href="#7-代码解析无法运行"></a> 7. 代码解析【无法运行】</h1><p>启动visdom：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m visdom.server</span><br></pre></td></tr></table></figure><p>编译prroi_pooling：</p><p>【失败】</p><p>找不到模块</p><h1 id="8-补充结合iou-net"><a class="markdownIt-Anchor" href="#8-补充结合iou-net"></a> 8. 补充【结合IoU-Net】</h1><p>追踪问题和目标检测问题的区别：</p><ul><li><p>追踪针对的目标类别是未知的，而检测问题是依赖于每个类别上的检测。</p><blockquote><p>论文说原有的IoU-Net是class-specific的，原因就在于此。</p></blockquote></li></ul><p>​但仍需要class-specific IoU predictor来对每一帧进行分析得到high-level nature。因为这个训练过程太费时，故而采用offline training来学习general representation用于IoU predictor。</p><p>​论文中的Fig.3就是实现了类似IoU-Net的功能，只不过是融合了reference的信息，最后输出的就是IoU分数。</p><blockquote><p>问题：该部分的输入（各种框）从哪里来？</p></blockquote><p><img src="/2020/03/06/atom/20190731160156261.png" alt="整体架构"></p><p><img src="/2020/03/06/atom/8.jpg" alt></p><p>​而online的部分就是负责区分background distractors，增强追踪的鲁棒性。我理解应该是两个语义比较接近的target，比如行人追踪中，其他的行人就可以理解为干扰对象。</p>]]></content>
      
      
      <categories>
          
          <category> IoU-Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoU-Net </tag>
            
            <tag> PrRoI Pooling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoU-Net</title>
      <link href="/2020/03/02/iou-net/"/>
      <url>/2020/03/02/iou-net/</url>
      
        <content type="html"><![CDATA[<h1 id="acquisition-of-localization-confidence-for-accurate-object-detectioniou-net"><a class="markdownIt-Anchor" href="#acquisition-of-localization-confidence-for-accurate-object-detectioniou-net"></a> Acquisition of Localization Confidence for Accurate Object Detection（IoU-Net）</h1><blockquote><p>Borui Jiang*, Ruixuan Luo*, Jiayuan Mao*, Tete Xiao, Yuning Jiang* (* indicates equal contribution.)</p></blockquote><p>paper：<a href="https://arxiv.org/abs/1807.11590">https://arxiv.org/abs/1807.11590</a></p><p>code：<a href="https://github.com/vacancy/PreciseRoIPooling">https://github.com/vacancy/PreciseRoIPooling</a></p><a id="more"></a><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><h2 id="11-传统方法"><a class="markdownIt-Anchor" href="#11-传统方法"></a> 1.1 传统方法</h2><p>​现阶段的two-stage目标检测器主要是解决multi-task learning problem：</p><ol><li>distinguish foreground object proposals from  background and assign them with proper class labels.</li><li>regress a set of coefficients which localize the object by maximizing intersection-over-union (IoU) or other metrics between detection results and the ground-truth.</li></ol><p>任务流程：</p><ol><li>RPN找出一系列候选框，区分前景背景。</li><li>对前景框进行分类和回归，得到每个框的分类置信度及回归坐标。</li><li>通过NMS，以分类置信度排序，过滤掉IoU大于一定阈值的框，得到最终的结果 。</li></ol><blockquote><p>例如FRCNN：</p><p>​并行输出两个任务：cls score + bbox offset，调整好bbox位置，再做NMS剔除冗余bbox。</p></blockquote><p>传统的NMS：</p><ul><li><p>classification confidence（有）</p><p>给每个proposal打class label，最后使用bbox regression来找到最符合GT的位置，最后，通过NMS消除冗余的bbox。</p></li><li><p>localization confidence（无）</p></li></ul><h3 id="111-传统方法缺陷"><a class="markdownIt-Anchor" href="#111-传统方法缺陷"></a> 1.1.1 传统方法缺陷</h3><p>由此带来的缺点：</p><ol><li>只用classification confidence作为metric for ranking the proposals。而忽略了localization accuracy，会导致IoU更大但cls score更小的框在NMS中被抑制。</li></ol><p><img src="/2020/03/02/iou-net/1.jpg" alt></p><blockquote><p>“bad money drives out good”</p></blockquote><p>​ the misalignment between classification confidence and localization accuracy may lead to accurately localized bounding boxes being suppressed by less accurate ones in the NMS procedure.</p><ol start="2"><li>缺乏localization confidence使bbox regression解释性变差；而且多次运用bbox reg会使bbox定位精度下降。</li></ol><p><img src="/2020/03/02/iou-net/2.jpg" alt></p><blockquote><p>non-monotonicity of iterative bounding box regression（非单调性）</p></blockquote><p>​That is, bounding box regression may degenerate the  localization of input bounding boxes if applied for multiple times.</p><h2 id="12-iou-net"><a class="markdownIt-Anchor" href="#12-iou-net"></a> 1.2 IoU-Net</h2><p>​IoU-Net使用待检测bbox和ground-truth box的IoU作为 localization criterion，可以解决前面提到的问题。</p><ol><li><p><mark>IoU-guided NMS</mark></p><p>​IoU是一个natural criterion for localization accuracy，使用predicted IoU作为ranking keyword in NMS</p></li><li><p><mark>Precise RoI Pooling</mark></p><p>​使用optimization-based bounding box refinement procedure替代原有的 traditional regression-based method，使用predicted IoU作为optimization objective，对于localization confidence也有很好的解释性；并且提供一个monotonic improvement。</p><p>​PrRoI Pooling layer使用梯度上升法解决IoU优化问题。</p></li></ol><h1 id="2-object-localization"><a class="markdownIt-Anchor" href="#2-object-localization"></a> 2. Object Localization</h1><p>​A standard <strong>FPN</strong> detector is trained on <strong>MS-COCO</strong><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>v</mi><mi>a</mi><mi>l</mi><mn>35</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">trainval35k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">3</span><span class="mord">5</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> as the <mark>baseline</mark> and tested on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">minival</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> for the study.</p><h2 id="21-misalignment-between-classification-confidence-and-localization-accuracy1"><a class="markdownIt-Anchor" href="#21-misalignment-between-classification-confidence-and-localization-accuracy1"></a> 2.1  misalignment between classification confidence and localization accuracy【1】</h2><h3 id="211-nms方法和一些改进"><a class="markdownIt-Anchor" href="#211-nms方法和一些改进"></a> 2.1.1 NMS方法和一些改进</h3><p><strong>[parameter free]</strong></p><ul><li><p>NMS：找到最大分类置信度的框，并把邻近的与该框重合大与predefined overlapping threshold值的框进行消除。</p></li><li><p>Soft-NMS：把NMS中的消除换成了降低置信度，leading to a higher recall。</p></li></ul><p><strong>[parameter-based methods]</strong>（需要更多计算力）</p><ul><li><p>Learning-based Algorithm：计算所有bbox的overlap矩阵，使用AP聚类进行选择。</p></li><li><p>GossipNet：后处理网络，基于bbox和cls confidence训练，替代NMS。</p></li><li><p>End-to-end network：使用端到端网络学习detected bbox之间的关系。</p></li></ul><h3 id="212-分析"><a class="markdownIt-Anchor" href="#212-分析"></a> 2.1.2  分析</h3><h4 id="2121-分布可视化"><a class="markdownIt-Anchor" href="#2121-分布可视化"></a> 2.1.2.1 分布可视化</h4><p>​在NMS步骤前，classification confidence和localization confidence在所有bbox中的分布可视化图如下：</p><p><img src="/2020/03/02/iou-net/3.jpg" alt></p><blockquote><p>x坐标表示detected box和ground-truth之间的IoU，y坐标表示其类别置信度。</p></blockquote><p>​通过分析Pearson correlation coefficient（皮尔逊相关系数，衡量线性相关程度），我们可以认为localization accuracy和分类置信度没有很大的相关性。</p><p>​上述情况产生的原因为：</p><p>​很多基于CNN的检测器在区分前景和背景时，如果检测到的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><msub><mi>x</mi><mrow><mi>d</mi><mi>e</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">box_{det}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与ground-truth之一的IoU &gt; 阈值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Omega_{train}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则认为是正例。言下之意即，如果IoU大与一定阈值的box就全部弄进来的话，会降低bbox定位的准确性。</p><p>​比如下图中分类置信度大但定位不太准确的红色框：</p><p><img src="/2020/03/02/iou-net/1.jpg" alt></p><h4 id="2122-nms-iou-guided-nms-no-nms"><a class="markdownIt-Anchor" href="#2122-nms-iou-guided-nms-no-nms"></a> 2.1.2.2 NMS / IoU-Guided NMS / No-NMS</h4><p><img src="/2020/03/02/iou-net/4.jpg" alt></p><blockquote><p>问题：为什么NMS和IoU-Guided NMS在0.5/0.6/0.7的时候产生的boxes比No-NMS的还多？</p><p>是否是因为在RPN中做的NMS，本身的anchor box就已经超出ground-truth很多了？</p><p><img src="/2020/03/02/iou-net/75922-20180306113548668-1747435774.jpg" alt="img"></p></blockquote><blockquote><p>问题：文章中的Repulsion Loss是指的什么？</p></blockquote><h2 id="22-non-monotonic-bounding-box-regression2"><a class="markdownIt-Anchor" href="#22-non-monotonic-bounding-box-regression2"></a> 2.2 Non-monotonic bounding box regression【2】</h2><p>​<em>Cai, Z., Vasconcelos, N.: Cascade r-cnn: Delving into high quality object detection. arXiv preprint arXiv:1712.00726 (2017)</em> 中提出应用bbox reg超过两次并不能带来显著提升，其原因是多步bbox reg产生了distribution mismatch，可以通过重采样策略解决这个问题。</p><p>​迭代bbox reg的性能如下图：</p><p><img src="/2020/03/02/iou-net/5.jpg" alt></p><h1 id="3-iou-net"><a class="markdownIt-Anchor" href="#3-iou-net"></a> 3. IoU-Net</h1><p><img src="/2020/03/02/iou-net/6.jpg" alt></p><p>​IoU predictor从FPN提取视觉特征并且对每个bbox估计localization accuracy（IoU）。</p><blockquote><p>问题：<strong>class-aware</strong> IoU predictors是什么意思？</p><p>+cls score //</p></blockquote><h2 id="31-iou-predictor"><a class="markdownIt-Anchor" href="#31-iou-predictor"></a> 3.1 IoU predictor</h2><p>​本文IoU预测器的输入不是用RPN产生的RoIs，而是对Ground Truth框随机扰动，得到Jittered RoIs，过滤掉与GT的IoU&lt;0.5的框，剩下的作为输入，经过PrRoI Pooling给IoU predictor。</p><h2 id="32-iou-guided-nms"><a class="markdownIt-Anchor" href="#32-iou-guided-nms"></a> 3.2 IoU-guided NMS</h2><p>​本文通过IoU-guided NMS来解决misalignment between classification confidence and localization accuracy问题。</p><p><img src="/2020/03/02/iou-net/7.jpg" alt></p><blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">S</mi></mrow><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.075em;">S</span></span></span></span></span>：classification confidence</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">I</mi></mrow><annotation encoding="application/x-tex">\mathcal{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span></span></span></span>：localization confidence（IoU）</p></blockquote><h2 id="33-bbox-refinement-as-an-optimization-procedure"><a class="markdownIt-Anchor" href="#33-bbox-refinement-as-an-optimization-procedure"></a> 3.3 bbox refinement as an optimization procedure</h2><p><img src="/2020/03/02/iou-net/8.jpg" alt></p><blockquote><p>比如在Fast RCNN框架中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>r</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">crit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span> 是用smooth-L1距离。<br>用回归的方式估计<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>c</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">c^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>，得到的结果受输入分布影响大，而且如Cascade RCNN指出，回归次数增加，效果会越来越差。</p></blockquote><p>​传统的Regression-based algorithms使用前馈网络直接估计最优解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>c</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">c^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>，然而该方法对于输入的分布不鲁棒，可能会导致monotonic localization improvement。</p><p>​本文提出optimization-based bbox refinement method，使用IoU-Net作为鲁棒的localization accuracy（IoU）estimator，更进一步地，IoU estimator还可以用作early-stop condition。</p><p><img src="/2020/03/02/iou-net/9.jpg" alt></p><p><img src="/2020/03/02/iou-net/10.jpg" alt></p><p><strong>算法流程：</strong></p><p>for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> =1 to T (最大迭代次数) :</p><ul><li>迭代输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b_j \in B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> (检测出的所有bbox)<ul><li>用PrPool来抽 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">b_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 特征，然后通过IoU分支得到梯度grad，以及分数PrevScore，</li><li>通过反向传播，更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></li><li>用新的 $ b_j$ 计算出新的分数NewScore</li><li>如果更新前后分数变化小于阈值，则将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>标记，存入A中，不进入下一次迭代</li></ul></li><li>直到B中所有bbox被存入A中，或者迭代到一定次数T才终止迭代</li></ul><h1 id="4-roi-pooling-roi-align-prroi-pooling"><a class="markdownIt-Anchor" href="#4-roi-pooling-roi-align-prroi-pooling"></a> 4. RoI Pooling / RoI Align / PrRoI Pooling</h1><h2 id="41-roi-pooling-以faster-rcnn为例"><a class="markdownIt-Anchor" href="#41-roi-pooling-以faster-rcnn为例"></a> 4.1 RoI Pooling 【以Faster RCNN为例】</h2><p><img src="/2020/03/02/iou-net/12.jpg" alt></p><h3 id="411-输入"><a class="markdownIt-Anchor" href="#411-输入"></a> 4.1.1 输入</h3><ol><li><p>特征图（feature map）：</p><p>​在Faster RCNN中，它是与RPN共享那个特征图，通常我们称之为“share_conv”。</p></li><li><p>RoIs：</p><p>​在Fast RCNN中，指的是Selective Search的输出；在Faster RCNN中指的是RPN的输出，一堆矩形候选框，形状为1x5x1x1（4个坐标+索引index）。</p><blockquote><p>问题：为什么形状是1x5x1x1 ？包含哪些数据？</p></blockquote><p>​其中值得注意的是：坐标的参考系不是针对feature map这张图的，而是<strong>针对原图</strong>的（神经网络最开始的输入）。</p></li></ol><h3 id="412-输出"><a class="markdownIt-Anchor" href="#412-输出"></a> 4.1.2 输出</h3><p>​输出是batch个vector，其中batch的值等于RoI的个数，vector的大小为channel * w * h；RoI Pooling的过程就是将一个个大小不同的box矩形框，都映射成大小固定（w * h）的矩形框。</p><h3 id="413-细节"><a class="markdownIt-Anchor" href="#413-细节"></a> 4.1.3 细节</h3><p><img src="/2020/03/02/iou-net/13.jpg" alt></p><p><img src="/2020/03/02/iou-net/14.jpg" alt></p><p>两次量化过程：</p><p>(1)、在原图上生成的region proposal 映射到feature map需要除以16或者32的时候，边界出现小数，这是第一次量化。</p><p>(2)、在每个roi里划分成k×k(7×7)的bins，对每个bin中均匀选取多少个采样点，然后进行max pooling，也会出现小数，这是第二次量化。</p><p><img src="/2020/03/02/iou-net/15.gif" alt></p><h3 id="414-反向传播"><a class="markdownIt-Anchor" href="#414-反向传播"></a> 4.1.4 反向传播</h3><blockquote><p>思考：RoI Pooling不能检测小物体</p><p>​因为bbox最后都统一为了7*7的大小，所以若待检的物体比较小的话（即初始框比较小），则会导致无法检测到。</p></blockquote><blockquote><p>待理解：RoI Pooling怎么进行反向传播？</p><p>见 <a href="https://zhuanlan.zhihu.com/p/59692298">你真的学会RoI Pooling了吗?</a></p></blockquote><p><img src="/2020/03/02/iou-net/equation.svg" alt="img"></p><p>​这里，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 代表池化前特征图上的像素点；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mrow><mi>r</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_{rj}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 代表池化后的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>个候选区域的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个点；$i^*(r,j) $代表点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mrow><mi>r</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_{rj}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 像素值的来源（最大池化的时候选出的最大像素值所在点的坐标）。由上式可以看出，只有当池化后某一个点的像素值在池化过程中采用了当前点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的像素值（即满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><msup><mi>i</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>r</mi><mi mathvariant="normal">，</mi><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i=i^*(r，j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>），才在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 处回传梯度。</p><p>![img]<code>(/</code>v2-e78fcd1ea642bfad66ec37b4e3e3c7ca_r.jpg)</p><h2 id="42-roi-align以mask-rcnn为例"><a class="markdownIt-Anchor" href="#42-roi-align以mask-rcnn为例"></a> 4.2 RoI Align【以Mask RCNN为例】</h2><p>​RoI Align是在[Mask RCNN](E:\SHU\optical_flow\papers\visual tracking\Mask R-CNN.pdf)中提出的，不需要对两步量化中产生的浮点数坐标的像素值都进行计算，而是设计了一套优雅的流程。</p><h3 id="421-细节"><a class="markdownIt-Anchor" href="#421-细节"></a> 4.2.1  细节</h3><p><img src="/2020/03/02/iou-net/16.jpg" alt></p><p>​基本步骤和RoI Pooling差不多，只是不对计算得到的浮点数进行量化取整，而是划分到最后小区域之后，在feature map上采样时采取双线性插值法计算。</p><p><img src="/2020/03/02/iou-net/17.jpg" alt></p><p>RoI Align示意图：</p><p>​假定采样点数为4，即表示，对于每个2.97 x 2.97的<strong>bin</strong>，<strong>平分四份小矩形，每一份取其中心点位置，而中心点位置的像素，采用双线性插值法进行计算</strong>，这样就会得到四个小数坐标点的像素值。</p><p><img src="/2020/03/02/iou-net/20.jpg" alt></p><h3 id="422-反向传播"><a class="markdownIt-Anchor" href="#422-反向传播"></a> 4.2.2 反向传播</h3><p>​类比于ROI Pooling，ROI Align的反向传播需要稍作修改。</p><p>​因为在ROIAlign中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i*(r,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>  是一个浮点数的坐标位置(前向传播时计算出来的采样点)，所以在池化前的特征图中，每一个与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i*(r,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 横纵坐标均小于1的点都应该接受与此对应的点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mrow><mi>r</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_{rj}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 回传的梯度，故ROI Align 的反向传播公式如下式所示。</p><p><img src="/2020/03/02/iou-net/equation-2.svg" alt="img"></p><p>​ 其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(.)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">.</span><span class="mclose">)</span></span></span></span> 表示两点之间的距离，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">\Delta h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault">h</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\Delta w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i*(r,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>横纵坐标的差值，这里作为双线性内插的系数乘在原始的梯度上。直观的理解就是离采样点越近的整数坐标点比重越大，极端的例子是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">\Delta h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault">h</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\Delta w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>都等于0的时候，就是当前采样点的值。</p><blockquote><p>卷积反向传播</p><p>​为了符合梯度计算，我们在误差矩阵周围填充了一圈0，此时我们将卷积核翻转后和反向传播的梯度误差进行卷积，就得到了前一次的梯度误差。</p></blockquote><h3 id="423-双线性插值法图像插值法"><a class="markdownIt-Anchor" href="#423-双线性插值法图像插值法"></a> 4.2.3 双线性插值法（图像插值法）</h3><p>​在图像的放大和缩小的过程中，需要计算新图像像素点在原图的位置，如果计算的位置不是整数，就需要用到图像的内插，我们需要寻找在原图中最近得像素点赋值给新的像素点，这种方法很简单是<strong>最近邻插法，<strong>这种方法好理解、简单，但是不实用，会产生是真现象，产生棋盘格效应，更实用的方法就是</strong>双线性插值法。</strong></p><p><strong>一维线性插值：</strong></p><p><img src="/2020/03/02/iou-net/18.jpg" alt></p><p><strong>双线性插值：</strong></p><p><img src="/2020/03/02/iou-net/19.jpg" alt></p><p>​先对红色点对（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Q</mi><mn>12</mn></msub><mo separator="true">,</mo><msub><mi>Q</mi><mn>22</mn></msub></mrow><annotation encoding="application/x-tex">Q_{12},Q_{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）和（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Q</mi><mn>11</mn></msub><mo separator="true">,</mo><msub><mi>Q</mi><mn>21</mn></msub></mrow><annotation encoding="application/x-tex">Q_{11},Q_{21}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）插值得到蓝色点，再对蓝色点对（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_1,R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）进行插值得到$ P$ 点的值。</p><h2 id="43-prroi-pooling本文提出"><a class="markdownIt-Anchor" href="#43-prroi-pooling本文提出"></a> 4.3 PrRoI  Pooling【本文提出】</h2><p>​因为RoI Align对于每个bin取出固定的点来做池化，这样对于bin的大小不具有适应性。PrRoI Pooling则使用二阶积分来做池化，可以避免量化。</p><p>​<mark>通过双线性插值，可以将feature map看成关于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>连续的函数</mark>，表达式为：</p><p><img src="/2020/03/02/iou-net/22.jpg" alt></p><p><img src="/2020/03/02/iou-net/23.jpg" alt></p><p>​其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">IC(x,y,i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>是插值系数，把RoI看成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>i</mi><mi>n</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">bin={(x_1,y_1),(x_2,y_2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1,y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是左上角的像素点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_2,y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是右下角的像素点。从特征图feature map和bin中进行polling采样可以用二阶积分来计算，即上式（3）。</p><p><img src="/2020/03/02/iou-net/24.jpg" alt></p><p>​由于PrRoI Pooling在前向传播时是连续可导的，其反向传播也是连续可导的，避免了任何量化。</p><p><img src="/2020/03/02/iou-net/29.jpg" alt></p><h2 id="44-三种方法对比"><a class="markdownIt-Anchor" href="#44-三种方法对比"></a> 4.4 三种方法对比</h2><p>​与RoI Pooling / RoI Align的对比图如下所示：</p><p><img src="/2020/03/02/iou-net/21.jpg" alt></p><p>​传统的RoI Pooling，需要进行两次量化；</p><p>​RoI Aling则在bin中通过双线性插值进行N=4的采样（即只采样四个点作为bin的代表），其中N是预定义的，不能自适应bin的大小；</p><p>​而本文提出的PrRoI Pooling把整个区域看做连续的，对于bin中白色的区域，都可以用双线性插值通过绿色的已知值得到，从而可以在连续的特征图上直接计算二阶积分，效果更好，更精确。</p><h1 id="5-总结experiments"><a class="markdownIt-Anchor" href="#5-总结experiments"></a> 5. 总结+Experiments</h1><p><img src="/2020/03/02/iou-net/30.jpg" alt></p><p><img src="/2020/03/02/iou-net/75922-20180306111851933-70273855.png" alt></p><ul><li>IoU-Guided NMS</li><li>bbox refinement as an optimization procedure (PrRoI Pooling)</li></ul><p><img src="/2020/03/02/iou-net/25.jpg" alt></p><p><img src="/2020/03/02/iou-net/26.jpg" alt></p><p><img src="/2020/03/02/iou-net/27.jpg" alt></p><p><img src="/2020/03/02/iou-net/28.jpg" alt></p><blockquote><p>速度开销不大，在可接受的范围内。</p></blockquote><p>文中对**<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msub><mi>P</mi><mn>50</mn></msub></mrow><annotation encoding="application/x-tex">AP_{50}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>结果较差**的原因也做了分析：</p><p>​我们主要将表3中AP50的较差结果归因于IoU估计误差。当边界框的真实IoU较低时，它们的外观差异就更⼤。如图2（b）所示，对于IoU较低的盒⼦，IoU估计变得不太准确。这降低了下游细化和抑制的性能。我们凭经验发现，可以通过诸如在训练过程中以较低的IoU采样更多边界框之类的技术来部分解决此问题。</p><h1 id="6-参考资料"><a class="markdownIt-Anchor" href="#6-参考资料"></a> 6. 参考资料</h1><ul><li>ROI Pooling原理及实现 <a href="https://blog.csdn.net/u011436429/article/details/80279536">https://blog.csdn.net/u011436429/article/details/80279536</a></li><li>论文笔记：(IOU-Net) Acquisition of Localization Confidence for Accurate Object Detection【翻译】<a href="https://blog.csdn.net/ctfabc4425/article/details/81490805">https://blog.csdn.net/ctfabc4425/article/details/81490805</a></li><li>IoUNet(2)_总结_ECCV2018 <a href="https://zhuanlan.zhihu.com/p/45518623">https://zhuanlan.zhihu.com/p/45518623</a></li><li>你真的学会RoI Pooling了吗? <a href="https://zhuanlan.zhihu.com/p/59692298">https://zhuanlan.zhihu.com/p/59692298</a></li><li>RoIPooling与RoIAlign的区别 <a href="https://blog.csdn.net/kk123k/article/details/86563425">https://blog.csdn.net/kk123k/article/details/86563425</a></li><li>ROI Pooling层解析 <a href="https://blog.csdn.net/a8039974/article/details/80811699">https://blog.csdn.net/a8039974/article/details/80811699</a></li><li>Precise RoI Pooling（PrRoI Pooling）笔记 <a href="https://blog.csdn.net/discoverer100/article/details/90519423">https://blog.csdn.net/discoverer100/article/details/90519423</a></li><li>ROI Pooling原理及实现 <a href="https://blog.csdn.net/u011436429/article/details/80279536">https://blog.csdn.net/u011436429/article/details/80279536</a></li><li>Faster R-CNN——RPN网络+ROI池化 (目标检测)(two-stage)(深度学习)(NIPS 2015)  <a href="https://blog.csdn.net/Gentleman_Qin/article/details/84403147">https://blog.csdn.net/Gentleman_Qin/article/details/84403147</a></li><li>随笔分类 - Faster-RCNN  <a href="https://www.cnblogs.com/wind-chaser/category/1526706.html">https://www.cnblogs.com/wind-chaser/category/1526706.html</a></li><li>【代码阅读】Faster RCNN 网络结构详解  <a href="https://blog.csdn.net/wqwqqwqw1231/article/details/100823263">https://blog.csdn.net/wqwqqwqw1231/article/details/100823263</a></li></ul><h1 id="7-代码解析"><a class="markdownIt-Anchor" href="#7-代码解析"></a> 7. 代码解析</h1><p>文件中的代码已经过时，需要更改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from jactorch.utils.unittest import TorchTestCase</span></span><br><span class="line"><span class="keyword">from</span> torchtestcase <span class="keyword">import</span> TorchTestCase</span><br></pre></td></tr></table></figure><p>安装ninja</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/ninja-build/ninja.git &amp;&amp; cd ninja</span><br><span class="line">git checkout release</span><br></pre></td></tr></table></figure><p>打开，进入ninja目录，输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python configure.py --bootstrap</span><br></pre></td></tr></table></figure><p>开始编译，成功后会在当前目录下生成ninja.exe（windows下），把该文件拷贝到系统目录C:/Windows/System32完成安装。</p><p>测试是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ninja ninja_test</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./ninja_test</span></span><br><span class="line">[214/226] SubprocessTest.SetWithLotsRaise [ulimit -n] above 1025 (currently 1024) to make this test go</span><br><span class="line">[226/226] ElideMiddle.ElideInTheMiddle</span><br><span class="line">passed</span><br></pre></td></tr></table></figure><p>运行出错：</p>]]></content>
      
      
      <categories>
          
          <category> IoU-Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoU-Net </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
